Unique Path (UPath)
Uunique
::	 = 	6
:	 = 	6
default	 = 	3
--	 = 	4
byte	 = 	1
?	 = 	1
@	 = 	2
=	 = 	3
>	 = 	3
;	 = 	28
<	 = 	3
)	 = 	16
*	 = 	1
synchronized	 = 	2
(	 = 	16
break	 = 	1
boolean	 = 	1
protected	 = 	5
char	 = 	1
throw	 = 	1
abstract	 = 	5
.	 = 	18
+	 = 	1
,	 = 	17
void	 = 	2
strictfp	 = 	3
catch	 = 	1
public	 = 	8
for	 = 	2
double	 = 	1
short	 = 	1
final	 = 	5
->	 = 	1
transient	 = 	1
throws	 = 	1
return	 = 	1
native	 = 	1
this	 = 	4
assert	 = 	1
++	 = 	4
new	 = 	5
volatile	 = 	1
}	 = 	9
~	 = 	1
{	 = 	9
|	 = 	1
long	 = 	1
interface	 = 	2
InfixOperator	 = 	1
do	 = 	1
import	 = 	1
extends	 = 	4
finally	 = 	1
implements	 = 	1
query	 = 	1
float	 = 	1
switch	 = 	1
instanceof	 = 	1
!	 = 	1
package	 = 	1
continue	 = 	1
while	 = 	2
]	 = 	6
else	 = 	1
[	 = 	6
super	 = 	8
-	 = 	1
Literal	 = 	1
try	 = 	1
AssignmentOperator	 = 	1
private	 = 	5
static	 = 	8
stictfp	 = 	1
class	 = 	4
SKIP	 = 	1
int	 = 	1
enum	 = 	1
...	 = 	1
if	 = 	1
and	 = 	1
case	 = 	1
Identifier	 = 	41
Token 	1	 = 	46
Token 	2	 = 	6
Token 	3	 = 	5
Token 	4	 = 	5
Token 	5	 = 	5
Token 	6	 = 	4
Token 	7	 = 	nil
Token 	8	 = 	3
Token 	9	 = 	2
Token 	10	 = 	nil
Unique tokens (# 45): !, *, +, -, ->, ..., ?, AssignmentOperator, InfixOperator, Literal, and, assert, boolean, break, byte, case, catch, char, continue, do, double, else, enum, finally, float, if, implements, import, instanceof, int, long, native, package, query, return, short, stictfp, switch, throw, throws, transient, try, volatile, |, ~
calcTail
compilation: 	;, __SKIP, __empty, }
basicType: 	boolean, byte, char, double, float, int, long, short
primitiveType: 	boolean, byte, char, double, float, int, long, short
referenceType: 	>, ], __Identifier
classType: 	>, __Identifier
type: 	>, __Identifier, boolean, byte, char, double, float, int, long, short
arrayType: 	]
typeVariable: 	__Identifier
dim: 	]
typeParameter: 	>, __Identifier
typeParameterModifier: 	), __Identifier
typeBound: 	>, __Identifier
additionalBound: 	>, __Identifier
typeArguments: 	>
typeArgumentList: 	>, ?, ], __Identifier
typeArgument: 	>, ?, ], __Identifier
wildcard: 	>, ?, ], __Identifier
wildcardBounds: 	>, ], __Identifier
qualIdent: 	__Identifier
compilationUnit: 	;, __empty, }
packageDeclaration: 	;
packageModifier: 	), __Identifier
importDeclaration: 	;
typeDeclaration: 	;, }
classDeclaration: 	}
normalClassDeclaration: 	}
classModifier: 	), __Identifier, abstract, final, private, protected, public, static, strictfp
typeParameters: 	>
typeParameterList: 	>, __Identifier
superclass: 	>, __Identifier
superinterfaces: 	>, __Identifier
interfaceTypeList: 	>, __Identifier
classBody: 	}
classBodyDeclaration: 	;, }
classMemberDeclaration: 	;, }
fieldDeclaration: 	;
variableDeclaratorList: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
variableDeclarator: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
variableDeclaratorId: 	], __Identifier
variableInitializer: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
unannClassType: 	>, __Identifier
unannType: 	>, ], __Identifier, boolean, byte, char, double, float, int, long, short
fieldModifier: 	), __Identifier, final, private, protected, public, static, transient, volatile
methodDeclaration: 	;, }
methodHeader: 	), >, ], __Identifier
methodDeclarator: 	), ]
formalParameterList: 	], __Identifier, this
formalParameter: 	], __Identifier
variableModifier: 	), __Identifier, final
receiverParameter: 	this
result: 	>, ], __Identifier, boolean, byte, char, double, float, int, long, short, void
methodModifier: 	), __Identifier, abstract, final, native, private, protected, public, static, stictfp, synchronized
throws: 	>, __Identifier
exceptionTypeList: 	>, __Identifier
exceptionType: 	>, __Identifier
methodBody: 	;, }
instanceInitializer: 	}
staticInitializer: 	}
constructorDeclaration: 	}
constructorDeclarator: 	)
constructorModifier: 	), __Identifier, private, protected, public
constructorBody: 	}
explicitConstructorInvocation: 	;
enumDeclaration: 	}
enumBody: 	}
enumConstantList: 	), __Identifier, }
enumConstant: 	), __Identifier, }
enumConstantModifier: 	), __Identifier
enumBodyDeclarations: 	;, }
interfaceDeclaration: 	}
normalInterfaceDeclaration: 	}
interfaceModifier: 	), __Identifier, abstract, private, protected, public, static, strictfp
extendsInterfaces: 	>, __Identifier
interfaceBody: 	}
interfaceMemberDeclaration: 	;, }
constantDeclaration: 	;
constantModifier: 	), __Identifier, final, public, static
interfaceMethodDeclaration: 	;, }
interfaceMethodModifier: 	), __Identifier, abstract, default, public, static, strictfp
annotationTypeDeclaration: 	}
annotationTypeBody: 	}
annotationTypeMemberDeclaration: 	;, }
annotationTypeElementDeclaration: 	;
annotationTypeElementModifier: 	), __Identifier, abstract, public
defaultValue: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
annotation: 	), __Identifier
normalAnnotation: 	)
elementValuePairList: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
elementValuePair: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
elementValue: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
elementValueArrayInitializer: 	}
elementValueList: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
markerAnnotation: 	__Identifier
singleElementAnnotation: 	)
arrayInitializer: 	}
variableInitializerList: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
block: 	}
blockStatements: 	;, }
blockStatement: 	;, }
localVariableDeclarationStatement: 	;
localVariableDeclaration: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
statement: 	;, }
statementExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
switchBlock: 	}
switchBlockStatementGroup: 	;, }
switchLabels: 	:
switchLabel: 	:
enumConstantName: 	__Identifier
basicForStatement: 	;, }
forInit: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
forUpdate: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
statementExpressionList: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
enhancedForStatement: 	;, }
tryStatement: 	}
catchClause: 	}
catchFormalParameter: 	], __Identifier
catchType: 	>, __Identifier
finally: 	}
resourceSpecification: 	)
resourceList: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
resource: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
expression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
primary: 	), ], __Identifier, __Literal, class, new, this, }
primaryBase: 	), ], __Identifier, __Literal, class, new, this, }
primaryRest: 	), ], __Identifier, }
parExpression: 	)
classCreator: 	), }
classTypeWithDiamond: 	>, __Identifier
typeArgumentsOrDiamond: 	>
arrayCreator: 	], }
dimExpr: 	]
arguments: 	)
argumentList: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
unaryExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
unaryExpressionNotPlusMinus: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
castExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
infixExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
InfixOperator: 	!=, %, &, &&, *, +, -, /, <, <<, <=, ==, >, >=, >>, >>>, ^, |, ||
conditionalExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
assignmentExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
assignment: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
leftHandSide: 	), ], __Identifier, __Literal, class, new, this, }
AssignmentOperator: 	%=, &=, *=, +=, -=, /=, <<=, =, >>=, >>>=, ^=, |=
lambdaExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
lambdaParameters: 	), __Identifier
inferredFormalParameterList: 	__Identifier
lambdaBody: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
constantExpression: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
Identifier: 	$, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, _, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z
Keywords: 	abstract, assert, boolean, break, byte, case, catch, char, class, const, continue, default, do, double, else, enum, extends, false, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, null, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, true, try, void, volatile, while
Literal: 	__BooleanLiteral, __CharLiteral, __FloatLiteral, __IntegerLiteral, __NullLiteral, __StringLiteral
IntegerLiteral: 	L, __BinaryNumeral, __DecimalNumeral, __HexNumeral, __OctalNumeral, l
DecimalNumeral: 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
HexNumeral: 	__HexDigits
OctalNumeral: 	0, 1, 2, 3, 4, 5, 6, 7
BinaryNumeral: 	0, 1
FloatLiteral: 	__DecimalFloatingPointLiteral, __HexaDecimalFloatingPointLiteral
DecimalFloatingPointLiteral: 	., D, F, __Digits, __Exponent, d, f
Exponent: 	__Digits
HexaDecimalFloatingPointLiteral: 	D, F, __BinaryExponent, d, f
HexSignificand: 	., __HexDigits, __HexNumeral
HexDigits: 	__HexDigit
HexDigit: 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, a, b, c, d, e, f
BinaryExponent: 	__Digits
Digits: 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
BooleanLiteral: 	false, true
CharLiteral: 	'
StringLiteral: 	"
NullLiteral: 	null
COMMENT: 	*/, //, __any
SPACE: 		, 
, , , ,  , __COMMENT
SKIP: 		, 
, , , ,  , __COMMENT, __empty
Global Prefix
compilation: 	
basicType: 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, >, [, __AssignmentOperator, __Identifier, __InfixOperator, abstract, assert, case, default, do, else, extends, final, instanceof, native, new, private, protected, public, query, return, static, stictfp, strictfp, super, synchronized, throw, transient, volatile, {, }, ~
primitiveType: 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, extends, instanceof, new, query, return, super, throw, {, }, ~
referenceType: 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, extends, instanceof, query, return, super, throw, {, }, ~
classType: 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __InfixOperator, and, assert, case, default, do, else, extends, implements, instanceof, new, query, return, super, throw, throws, {, |, }, ~
type: 	new
arrayType: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
typeVariable: 	,, extends, throws
dim: 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short
typeParameter: 	,, <
typeParameterModifier: 	), ,, <, __Identifier
typeBound: 	__Identifier
additionalBound: 	>, ], __Identifier
typeArguments: 	., ::, __Identifier, new, {
typeArgumentList: 	<
typeArgument: 	,, <
wildcard: 	,, <
wildcardBounds: 	?
qualIdent: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, @, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, import, query, return, static, throw, {, }, ~
compilationUnit: 	__SKIP
packageDeclaration: 	__SKIP
packageModifier: 	), __Identifier, __SKIP
importDeclaration: 	;, __SKIP
typeDeclaration: 	;, __SKIP, }
classDeclaration: 	:, ;, __SKIP, {, }
normalClassDeclaration: 	:, ;, __SKIP, {, }
classModifier: 	), :, ;, __Identifier, __SKIP, abstract, final, private, protected, public, static, strictfp, {, }
typeParameters: 	), ;, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, {, }
typeParameterList: 	<
superclass: 	>, __Identifier
superinterfaces: 	>, __Identifier
interfaceTypeList: 	extends, implements
classBody: 	), >, __Identifier
classBodyDeclaration: 	;, {, }
classMemberDeclaration: 	;, {, }
fieldDeclaration: 	;, {, }
variableDeclaratorList: 	>, ], __Identifier, boolean, byte, char, double, float, int, long, short
variableDeclarator: 	,, >, ], __Identifier, boolean, byte, char, double, float, int, long, short
variableDeclaratorId: 	,, ..., >, ], __Identifier, boolean, byte, char, double, float, int, long, short
variableInitializer: 	,, =, {
unannClassType: 	(, ), ,, :, ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, transient, volatile, {, }
unannType: 	(, ), ,, :, ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, transient, volatile, {, }
fieldModifier: 	), ;, __Identifier, final, private, protected, public, static, transient, volatile, {, }
methodDeclaration: 	;, {, }
methodHeader: 	), ;, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, {, }
methodDeclarator: 	>, ], __Identifier, boolean, byte, char, double, float, int, long, short, void
formalParameterList: 	(
formalParameter: 	(, ,
variableModifier: 	(, ), ,, :, ;, __Identifier, final, {, }
receiverParameter: 	(
result: 	), ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, {, }
methodModifier: 	), ;, __Identifier, abstract, final, native, private, protected, public, static, stictfp, synchronized, {, }
throws: 	), ]
exceptionTypeList: 	throws
exceptionType: 	,, throws
methodBody: 	), >, ], __Identifier
instanceInitializer: 	;, {, }
staticInitializer: 	;, {, }
constructorDeclaration: 	;, {, }
constructorDeclarator: 	), ;, __Identifier, private, protected, public, {, }
constructorModifier: 	), ;, __Identifier, private, protected, public, {, }
constructorBody: 	), >, __Identifier
explicitConstructorInvocation: 	{
enumDeclaration: 	:, ;, __SKIP, {, }
enumBody: 	>, __Identifier
enumConstantList: 	{
enumConstant: 	,, {
enumConstantModifier: 	), ,, __Identifier, {
enumBodyDeclarations: 	), ,, __Identifier, {, }
interfaceDeclaration: 	;, __SKIP, {, }
normalInterfaceDeclaration: 	;, __SKIP, {, }
interfaceModifier: 	), ;, __Identifier, __SKIP, abstract, private, protected, public, static, strictfp, {, }
extendsInterfaces: 	>, __Identifier
interfaceBody: 	>, __Identifier
interfaceMemberDeclaration: 	;, {, }
constantDeclaration: 	;, {, }
constantModifier: 	), ;, __Identifier, final, public, static, {, }
interfaceMethodDeclaration: 	;, {, }
interfaceMethodModifier: 	), ;, __Identifier, abstract, default, public, static, strictfp, {, }
annotationTypeDeclaration: 	;, __SKIP, {, }
annotationTypeBody: 	__Identifier
annotationTypeMemberDeclaration: 	;, {, }
annotationTypeElementDeclaration: 	;, {, }
annotationTypeElementModifier: 	), ;, __Identifier, abstract, public, {, }
defaultValue: 	), ]
annotation: 	!, (, ), +, ++, ,, -, --, ->, ., :, ;, <, =, >, [, ], __AssignmentOperator, __Identifier, __InfixOperator, __SKIP, abstract, and, assert, boolean, byte, case, char, default, do, double, else, extends, final, float, implements, instanceof, int, long, native, new, private, protected, public, query, return, short, static, stictfp, strictfp, super, synchronized, throw, throws, transient, volatile, {, |, }, ~
normalAnnotation: 	@
elementValuePairList: 	(, ), ++, --, >, ], __Identifier, __Literal, class, new, this, }
elementValuePair: 	(, ), ++, ,, --, >, ], __Identifier, __Literal, class, new, this, }
elementValue: 	(, ,, =, default, {
elementValueArrayInitializer: 	(, ,, =, default, {
elementValueList: 	{
markerAnnotation: 	@
singleElementAnnotation: 	@
arrayInitializer: 	,, =, ], {
variableInitializerList: 	{
block: 	), ->, :, ;, >, ], __Identifier, do, else, finally, static, try, {, }
blockStatements: 	:, ;, {
blockStatement: 	:, ;, {, }
localVariableDeclarationStatement: 	:, ;, {, }
localVariableDeclaration: 	(, :, ;, {, }
statement: 	), :, ;, do, else, {, }
statementExpression: 	(, ), ,, :, ;, do, else, {, }
switchBlock: 	)
switchBlockStatementGroup: 	;, {, }
switchLabels: 	;, {, }
switchLabel: 	:, ;, {, }
enumConstantName: 	case
basicForStatement: 	), :, ;, do, else, {, }
forInit: 	(
forUpdate: 	;
statementExpressionList: 	(, ;
enhancedForStatement: 	), :, ;, do, else, {, }
tryStatement: 	), :, ;, do, else, {, }
catchClause: 	}
catchFormalParameter: 	(
catchType: 	(, ), __Identifier, final
finally: 	}
resourceSpecification: 	try
resourceList: 	(
resource: 	(, ,
expression: 	(, ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {
primary: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
primaryBase: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
primaryRest: 	), ], __Identifier, __Literal, class, new, this, }
parExpression: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, if, query, return, switch, synchronized, throw, while, {, }, ~
classCreator: 	new
classTypeWithDiamond: 	), >, __Identifier, new
typeArgumentsOrDiamond: 	__Identifier
arrayCreator: 	new
dimExpr: 	]
arguments: 	>, __Identifier, super, this
argumentList: 	(
unaryExpression: 	!, (, ), +, ,, -, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, query, return, throw, {, ~
unaryExpressionNotPlusMinus: 	!, (, ), +, ,, -, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, query, return, throw, {, ~
castExpression: 	!, (, ), +, ,, -, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, query, return, throw, {, ~
infixExpression: 	(, ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, default, query, return, throw, {
InfixOperator: 	), ++, --, >, ], __Identifier, __Literal, class, new, this, }
conditionalExpression: 	(, ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, default, query, return, throw, {
assignmentExpression: 	(, ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {
assignment: 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, do, else, query, return, throw, {, }
leftHandSide: 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, do, else, query, return, throw, {, }
AssignmentOperator: 	), ], __Identifier, __Literal, class, new, this, }
lambdaExpression: 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {
lambdaParameters: 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {
inferredFormalParameterList: 	(
lambdaBody: 	->
constantExpression: 	case
Identifier: 	!, (, ), +, ++, ,, -, --, ->, ., ..., :, ::, ;, <, =, >, @, [, ], __AssignmentOperator, __Identifier, __InfixOperator, __Literal, abstract, and, assert, boolean, break, byte, case, char, class, continue, default, do, double, else, enum, extends, final, float, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, query, return, short, static, stictfp, strictfp, super, synchronized, this, throw, throws, transient, void, volatile, {, |, }, ~
Keywords: 	
Literal: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
IntegerLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
DecimalNumeral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
HexNumeral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
OctalNumeral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
BinaryNumeral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
FloatLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
DecimalFloatingPointLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
Exponent: 	., __Digits
HexaDecimalFloatingPointLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
HexSignificand: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
HexDigits: 	., 0X, 0x
HexDigit: 	., 0X, 0x, _, __HexDigit
BinaryExponent: 	__HexSignificand
Digits: 	!, (, ), +, ++, ,, -, --, ->, ., :, ;, =, E, P, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, e, else, p, query, return, throw, {, }, ~
BooleanLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
CharLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
StringLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
NullLiteral: 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~
COMMENT: 		, 
, , , ,  , __COMMENT
SPACE: 	
SKIP: 	
foi true22
passou três	compilationUnit	compilation
UniqueFlwVar	compilationUnit	rule = 	compilation	pref = 	__SKIP	flw = 	$
UniqueFlwVar	annotation	rule = 	primitiveType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, assert, case, default, do, else, extends, instanceof, new, query, return, super, throw, {, }, ~	flw = 	@, boolean, byte, char, double, float, int, long, short
UniqueFlwVar	primitiveType	rule = 	referenceType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, extends, instanceof, query, return, super, throw, {, }, ~	flw = 	), ,, :, ::, ;, >, @, [, ], __Identifier, __InfixOperator, and, instanceof, query, }
UniqueFlwVar	annotation	rule = 	classType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, and, assert, case, default, do, else, extends, implements, instanceof, new, query, return, super, throw, throws, {, |, }, ~	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classType	pref = 	), ., __Identifier	flw = 	@, __Identifier
passou três	primitiveType	type
UniqueFlwVar	primitiveType	rule = 	arrayType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	::, @, [
UniqueFlwVar	annotation	rule = 	typeVariable	pref = 	), ,, __Identifier, extends, throws	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	dim	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	@, [
UniqueFlwVar	typeParameterModifier	rule = 	typeParameter	pref = 	), ,, <, __Identifier	flw = 	@, __Identifier
foi true22
passou três	classType	additionalBound
passou três	wildcard	typeArgument
UniqueFlwVar	annotation	rule = 	wildcard	pref = 	), ,, <, __Identifier	flw = 	?, @
foi true22
passou três	wildcardBounds	wildcard
foi true22
foi true22
passou três	referenceType	wildcardBounds
UniqueFlwVar	packageModifier	rule = 	packageDeclaration	pref = 	), __Identifier, __SKIP	flw = 	@, package
foi true22
foi true22
foi true22
foi true22
foi true22
foi true22
UniqueFlwVar	typeParameters	rule = 	normalClassDeclaration	pref = 	__Identifier	flw = 	extends, implements, {
UniqueFlwVar	superclass	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	implements, {
UniqueFlwVar	superinterfaces	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
passou três	interfaceTypeList	superinterfaces
UniqueFlwVar	annotation	rule = 	unannClassType	pref = 	), ., __Identifier	flw = 	@, __Identifier
UniqueFlwVar	basicType	rule = 	unannType	pref = 	(, ), ,, :, ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, transient, volatile, {, }	flw = 	..., @, [, __Identifier, this
UniqueFlwVar	annotation	rule = 	methodHeader	pref = 	), >, __Identifier	flw = 	@, __Identifier, boolean, byte, char, double, float, int, long, short, void
UniqueFlwVar	annotation	rule = 	formalParameter	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	..., @
foi true22
passou três	variableDeclaratorId	formalParameter
UniqueFlwVar	variableDeclaratorId	rule = 	formalParameter	pref = 	...	flw = 	), ,
UniqueFlw	__void	rule = 	result	pref = 	), ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, {, }	flw = 	__Identifier	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlw	__synchronized	rule = 	methodModifier	pref = 	), ;, __Identifier, abstract, final, native, private, protected, public, static, stictfp, synchronized, {, }	flw = 	<, @, __Identifier, abstract, boolean, byte, char, double, final, float, int, long, native, private, protected, public, short, static, stictfp, synchronized, void	nInt = 	1	nEq = 	0	pflw = 	nil
foi true22
passou três	exceptionTypeList	throws
passou três	exceptionType	exceptionTypeList
UniqueFlwVar	exceptionType	rule = 	exceptionTypeList	pref = 	throws	flw = 	,, ;, {
passou três	block	staticInitializer
UniqueFlwVar	throws	rule = 	constructorDeclaration	pref = 	)	flw = 	{
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	this
passou três	arguments	explicitConstructorInvocation
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	this	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
foi true22
foi true22
UniqueFlwVar	superinterfaces	rule = 	enumDeclaration	pref = 	__Identifier	flw = 	{
UniqueFlwVar	enumConstantModifier	rule = 	enumConstant	pref = 	), ,, __Identifier, {	flw = 	@, __Identifier
foi true22
UniqueFlwVar	typeParameters	rule = 	normalInterfaceDeclaration	pref = 	__Identifier	flw = 	extends, {
UniqueFlwVar	extendsInterfaces	rule = 	normalInterfaceDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
UniqueFlwVar	defaultValue	rule = 	annotationTypeElementDeclaration	pref = 	), ]	flw = 	;
passou três	normalAnnotation	annotation
passou três	singleElementAnnotation	annotation
passou três	markerAnnotation	annotation
UniqueFlwVar	qualIdent	rule = 	normalAnnotation	pref = 	@	flw = 	(
UniqueFlwVar	qualIdent	rule = 	singleElementAnnotation	pref = 	@	flw = 	(
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	if	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	statement	rule = 	statement	pref = 	do	flw = 	while
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	;
passou três	tryStatement	statement
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	switch	flw = 	{
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	synchronized	flw = 	{
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	return	flw = 	;
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	throw	flw = 	;
foi true22
foi true22
foi true22
foi true22
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	assert	flw = 	:, ;
UniqueFlwVar	expression	rule = 	statement	pref = 	:	flw = 	;
UniqueFlwVar	primary	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
UniqueFlwVar	qualIdent	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
foi true22
UniqueFlwVar	forInit	rule = 	basicForStatement	pref = 	(	flw = 	;
UniqueFlwVar	expression	rule = 	basicForStatement	pref = 	;	flw = 	;
UniqueFlwVar	expression	rule = 	enhancedForStatement	pref = 	:	flw = 	)
foi true22
passou três	block	tryStatement
UniqueFlwVar	block	rule = 	tryStatement	pref = 	try	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	catch, finally
passou três	resourceSpecification	tryStatement
UniqueFlwVar	resourceSpecification	rule = 	tryStatement	pref = 	try	flw = 	{
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
foi true22
foi true22
foi true22
passou três	classType	catchType
foi true22
passou três	block	finally
foi true22
UniqueFlw	__this	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	), ++, ,, --, ., :, ::, ;, [, ], __AssignmentOperator, __Identifier, __InfixOperator, instanceof, query, }	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	expression	rule = 	primaryBase	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	basicType	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	., [
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	new
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	.	flw = 	__Identifier
UniqueFlwVar	expression	rule = 	primaryRest	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	::	flw = 	__Identifier
passou três	typeArguments	classCreator
UniqueFlwVar	typeArguments	rule = 	classCreator	pref = 	new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classCreator	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	typeArgumentsOrDiamond	rule = 	classTypeWithDiamond	pref = 	__Identifier	flw = 	(, .
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), ., __Identifier	flw = 	@, __Identifier
foi true22
UniqueFlwVar	type	rule = 	arrayCreator	pref = 	new	flw = 	@, [, {
UniqueFlwVar	annotation	rule = 	dimExpr	pref = 	), ], __Identifier	flw = 	@, [
UniqueFlwVar	expression	rule = 	dimExpr	pref = 	[	flw = 	]
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
UniqueFlwVar	primitiveType	rule = 	castExpression	pref = 	(	flw = 	)
foi true22
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
foi true22
passou três	unaryExpression	infixExpression
foi true22
passou três	referenceType	infixExpression
foi true22
passou três	expression	conditionalExpression
UniqueFlwVar	expression	rule = 	conditionalExpression	pref = 	query	flw = 	:
UniqueFlwVar	leftHandSide	rule = 	assignment	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, do, else, query, return, throw, {, }	flw = 	__AssignmentOperator
foi true22
passou três	expression	assignment
UniqueFlwVar	lambdaParameters	rule = 	lambdaExpression	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->
foi true22
passou três	lambdaBody	lambdaExpression
UniqueFlw	Identifier	rule = 	lambdaParameters	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->	nInt = 	17	nEq = 	3	pflw = 	nil
passou três	expression	lambdaBody
passou três	block	lambdaBody
unique var 	compilationUnit
Unique usage	compilationUnit
unique var 	typeArguments
unique var 	annotation
unique var 	typeArguments
unique var 	typeBound
Unique usage	typeBound
unique var 	typeVariable
unique var 	classType
unique var 	wildcardBounds
Unique usage	wildcardBounds
unique var 	referenceType
unique var 	referenceType
unique var 	typeDeclaration
Unique usage	typeDeclaration
unique var 	qualIdent
unique var 	interfaceDeclaration
unique var 	typeParameters
unique var 	superclass
Unique usage	superclass
unique var 	superinterfaces
unique var 	classBody
unique var 	classType
unique var 	interfaceTypeList
unique var 	typeArguments
unique var 	methodDeclarator
unique var 	throws
unique var 	variableDeclaratorId
unique var 	exceptionTypeList
Unique usage	exceptionTypeList
unique var 	exceptionType
unique var 	exceptionType
Unique usage	exceptionType
unique var 	typeVariable
Unique usage	typeVariable
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	superinterfaces
Unique usage	superinterfaces
unique var 	enumBody
Unique usage	enumBody
unique var 	enumConstantList
Unique usage	enumConstantList
unique var 	enumBodyDeclarations
Unique usage	enumBodyDeclarations
unique var 	enumConstant
unique var 	arguments
unique var 	classBody
unique var 	classBodyDeclaration
unique var 	typeParameters
unique var 	extendsInterfaces
Unique usage	extendsInterfaces
unique var 	interfaceBody
Unique usage	interfaceBody
unique var 	interfaceTypeList
Unique usage	interfaceTypeList
unique var 	interfaceMemberDeclaration
Unique usage	interfaceMemberDeclaration
unique var 	interfaceDeclaration
unique var 	annotationTypeBody
Unique usage	annotationTypeBody
unique var 	annotationTypeMemberDeclaration
Unique usage	annotationTypeMemberDeclaration
unique var 	interfaceDeclaration
unique var 	elementValuePairList
Unique usage	elementValuePairList
unique var 	elementValuePair
unique var 	elementValuePair
Unique usage	elementValuePair
unique var 	elementValue
unique var 	elementValue
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var 	parExpression
unique var 	parExpression
unique var 	switchBlock
Unique usage	switchBlock
unique var 	block
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	switchLabel
unique var 	enumConstantName
Unique usage	enumConstantName
unique var 	expression
unique var 	forUpdate
Unique usage	forUpdate
unique var 	statement
unique var 	statementExpressionList
unique var 	statement
unique var 	block
unique var 	catchClause
unique var 	resourceSpecification
Unique usage	resourceSpecification
unique var 	block
unique var 	catchClause
unique var 	finally
Unique usage	finally
unique var 	catchFormalParameter
Unique usage	catchFormalParameter
unique var 	block
unique var 	variableModifier
unique var 	catchType
Unique usage	catchType
unique var 	variableDeclaratorId
unique var 	unannClassType
unique var 	classType
unique var 	block
unique var 	resourceList
Unique usage	resourceList
unique var 	resource
unique var 	resource
Unique usage	resource
unique var 	variableModifier
unique var 	unannType
unique var 	variableDeclaratorId
unique var 	expression
unique var 	arguments
unique var 	arrayCreator
Unique usage	arrayCreator
unique var 	arguments
unique var 	arguments
unique var 	typeArguments
unique var 	arguments
unique var 	arguments
unique var 	classTypeWithDiamond
Unique usage	classTypeWithDiamond
unique var 	arguments
unique var 	classBody
Unique usage	classBody
unique var 	annotation
unique var 	typeArgumentsOrDiamond
unique var 	annotation
unique var 	typeArgumentsOrDiamond
Unique usage	typeArgumentsOrDiamond
unique var 	type
unique var 	dim
unique var 	arrayInitializer
unique var 	expression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	lambdaExpression
unique var 	unaryExpressionNotPlusMinus
unique var 	unaryExpression
unique var 	referenceType
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	lambdaBody
Unique usage	lambdaBody
unique var 	expression
unique var 	block
foi true22
UniqueFlwVar	compilationUnit	rule = 	compilation	pref = 	__SKIP	flw = 	$
UniqueFlwVar	annotation	rule = 	primitiveType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, assert, case, default, do, else, extends, instanceof, new, query, return, super, throw, {, }, ~	flw = 	@, boolean, byte, char, double, float, int, long, short
UniqueFlwVar	primitiveType	rule = 	referenceType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, extends, instanceof, query, return, super, throw, {, }, ~	flw = 	), ,, :, ::, ;, >, @, [, ], __Identifier, __InfixOperator, and, instanceof, query, }
UniqueFlwVar	annotation	rule = 	classType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, and, assert, case, default, do, else, extends, implements, instanceof, new, query, return, super, throw, throws, {, |, }, ~	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classType	pref = 	), ., __Identifier	flw = 	@, __Identifier
passou três	primitiveType	type
UniqueFlwVar	primitiveType	rule = 	arrayType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	::, @, [
UniqueFlwVar	annotation	rule = 	typeVariable	pref = 	), ,, __Identifier, extends, throws	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	dim	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	@, [
UniqueFlwVar	typeParameterModifier	rule = 	typeParameter	pref = 	), ,, <, __Identifier	flw = 	@, __Identifier
foi true22
passou três	classType	additionalBound
UniqueFlwVar	annotation	rule = 	wildcard	pref = 	), ,, <, __Identifier	flw = 	?, @
foi true22
foi true22
foi true22
passou três	referenceType	wildcardBounds
UniqueFlwVar	packageModifier	rule = 	packageDeclaration	pref = 	), __Identifier, __SKIP	flw = 	@, package
foi true22
foi true22
foi true22
foi true22
foi true22
foi true22
UniqueFlwVar	typeParameters	rule = 	normalClassDeclaration	pref = 	__Identifier	flw = 	extends, implements, {
UniqueFlwVar	superclass	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	implements, {
UniqueFlwVar	superinterfaces	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
passou três	interfaceTypeList	superinterfaces
UniqueFlwVar	annotation	rule = 	unannClassType	pref = 	), ., __Identifier	flw = 	@, __Identifier
UniqueFlwVar	basicType	rule = 	unannType	pref = 	(, ), ,, :, ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, transient, volatile, {, }	flw = 	..., @, [, __Identifier, this
UniqueFlwVar	annotation	rule = 	methodHeader	pref = 	), >, __Identifier	flw = 	@, __Identifier, boolean, byte, char, double, float, int, long, short, void
UniqueFlwVar	annotation	rule = 	formalParameter	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	..., @
foi true22
passou três	variableDeclaratorId	formalParameter
UniqueFlwVar	variableDeclaratorId	rule = 	formalParameter	pref = 	...	flw = 	), ,
UniqueFlw	__void	rule = 	result	pref = 	), ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, {, }	flw = 	__Identifier	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlw	__synchronized	rule = 	methodModifier	pref = 	), ;, __Identifier, abstract, final, native, private, protected, public, static, stictfp, synchronized, {, }	flw = 	<, @, __Identifier, abstract, boolean, byte, char, double, final, float, int, long, native, private, protected, public, short, static, stictfp, synchronized, void	nInt = 	1	nEq = 	0	pflw = 	nil
foi true22
UniqueFlwVar	exceptionType	rule = 	exceptionTypeList	pref = 	throws	flw = 	,, ;, {
passou três	block	staticInitializer
UniqueFlwVar	throws	rule = 	constructorDeclaration	pref = 	)	flw = 	{
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	this
passou três	arguments	explicitConstructorInvocation
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	this	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
foi true22
foi true22
UniqueFlwVar	superinterfaces	rule = 	enumDeclaration	pref = 	__Identifier	flw = 	{
UniqueFlwVar	enumConstantModifier	rule = 	enumConstant	pref = 	), ,, __Identifier, {	flw = 	@, __Identifier
foi true22
UniqueFlwVar	typeParameters	rule = 	normalInterfaceDeclaration	pref = 	__Identifier	flw = 	extends, {
UniqueFlwVar	extendsInterfaces	rule = 	normalInterfaceDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
UniqueFlwVar	defaultValue	rule = 	annotationTypeElementDeclaration	pref = 	), ]	flw = 	;
passou três	markerAnnotation	annotation
UniqueFlwVar	qualIdent	rule = 	normalAnnotation	pref = 	@	flw = 	(
UniqueFlwVar	qualIdent	rule = 	singleElementAnnotation	pref = 	@	flw = 	(
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	if	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	statement	rule = 	statement	pref = 	do	flw = 	while
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	;
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	switch	flw = 	{
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	synchronized	flw = 	{
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	return	flw = 	;
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	throw	flw = 	;
foi true22
foi true22
foi true22
foi true22
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	assert	flw = 	:, ;
UniqueFlwVar	expression	rule = 	statement	pref = 	:	flw = 	;
UniqueFlwVar	primary	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
UniqueFlwVar	qualIdent	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
foi true22
UniqueFlwVar	forInit	rule = 	basicForStatement	pref = 	(	flw = 	;
UniqueFlwVar	expression	rule = 	basicForStatement	pref = 	;	flw = 	;
UniqueFlwVar	expression	rule = 	enhancedForStatement	pref = 	:	flw = 	)
foi true22
passou três	block	tryStatement
UniqueFlwVar	block	rule = 	tryStatement	pref = 	try	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	catch, finally
UniqueFlwVar	resourceSpecification	rule = 	tryStatement	pref = 	try	flw = 	{
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
foi true22
foi true22
foi true22
passou três	classType	catchType
foi true22
passou três	block	finally
foi true22
UniqueFlw	__this	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	), ++, ,, --, ., :, ::, ;, [, ], __AssignmentOperator, __Identifier, __InfixOperator, instanceof, query, }	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	expression	rule = 	primaryBase	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	basicType	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	., [
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	new
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	.	flw = 	__Identifier
UniqueFlwVar	expression	rule = 	primaryRest	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	::	flw = 	__Identifier
passou três	typeArguments	classCreator
UniqueFlwVar	typeArguments	rule = 	classCreator	pref = 	new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classCreator	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	typeArgumentsOrDiamond	rule = 	classTypeWithDiamond	pref = 	__Identifier	flw = 	(, .
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), ., __Identifier	flw = 	@, __Identifier
foi true22
UniqueFlwVar	type	rule = 	arrayCreator	pref = 	new	flw = 	@, [, {
UniqueFlwVar	annotation	rule = 	dimExpr	pref = 	), ], __Identifier	flw = 	@, [
UniqueFlwVar	expression	rule = 	dimExpr	pref = 	[	flw = 	]
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
UniqueFlwVar	primitiveType	rule = 	castExpression	pref = 	(	flw = 	)
foi true22
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
foi true22
passou três	unaryExpression	infixExpression
foi true22
passou três	referenceType	infixExpression
foi true22
passou três	expression	conditionalExpression
UniqueFlwVar	expression	rule = 	conditionalExpression	pref = 	query	flw = 	:
UniqueFlwVar	leftHandSide	rule = 	assignment	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, do, else, query, return, throw, {, }	flw = 	__AssignmentOperator
foi true22
passou três	expression	assignment
UniqueFlwVar	lambdaParameters	rule = 	lambdaExpression	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->
foi true22
UniqueFlw	Identifier	rule = 	lambdaParameters	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->	nInt = 	17	nEq = 	3	pflw = 	nil
passou três	expression	lambdaBody
passou três	block	lambdaBody
unique var 	compilationUnit
Unique usage	compilationUnit
unique var 	typeArguments
unique var 	annotation
unique var 	typeArguments
unique var 	annotation
unique var 	typeBound
Unique usage	typeBound
unique var 	typeVariable
Unique usage	typeVariable
unique var 	classType
unique var2 	wildcard
unique var 	wildcardBounds
Unique usage	wildcardBounds
unique var 	referenceType
unique var 	referenceType
unique var2 	packageDeclaration
unique var 	typeDeclaration
Unique usage	typeDeclaration
unique var 	qualIdent
unique var 	interfaceDeclaration
unique var2 	normalClassDeclaration
unique var2 	enumDeclaration
unique var 	typeParameters
unique var 	superclass
Unique usage	superclass
unique var 	superinterfaces
Unique usage	superinterfaces
unique var 	classBody
Unique usage	classBody
unique var 	typeParameter
Unique usage	typeParameter
unique var 	classType
unique var 	interfaceTypeList
Unique usage	interfaceTypeList
unique var 	classType
unique var 	classType
unique var 	classBodyDeclaration
Unique usage	classBodyDeclaration
unique var 	instanceInitializer
Unique usage	instanceInitializer
unique var 	staticInitializer
Unique usage	staticInitializer
unique var 	constructorDeclaration
Unique usage	constructorDeclaration
unique var 	typeArguments
unique var 	methodDeclarator
unique var 	throws
unique var 	variableDeclaratorId
unique var 	exceptionTypeList
Unique usage	exceptionTypeList
unique var 	exceptionType
Unique usage	exceptionType
unique var 	exceptionType
Unique usage	exceptionType
unique var 	typeVariable
Unique usage	typeVariable
unique var 	block
unique var 	block
unique var 	constructorModifier
Unique usage	constructorModifier
unique var 	constructorDeclarator
Unique usage	constructorDeclarator
unique var 	throws
unique var 	constructorBody
Unique usage	constructorBody
unique var 	typeParameters
unique var 	formalParameterList
unique var 	annotation
unique var2 	explicitConstructorInvocation
unique var 	blockStatements
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	superinterfaces
Unique usage	superinterfaces
unique var 	enumBody
Unique usage	enumBody
unique var 	enumConstantList
Unique usage	enumConstantList
unique var 	enumBodyDeclarations
Unique usage	enumBodyDeclarations
unique var 	enumConstant
Unique usage	enumConstant
unique var 	enumConstantModifier
Unique usage	enumConstantModifier
unique var 	arguments
unique var 	classBody
Unique usage	classBody
unique var 	annotation
unique var 	classBodyDeclaration
Unique usage	classBodyDeclaration
unique var2 	normalInterfaceDeclaration
unique var2 	annotationTypeDeclaration
unique var 	typeParameters
unique var 	extendsInterfaces
Unique usage	extendsInterfaces
unique var 	interfaceBody
Unique usage	interfaceBody
unique var 	interfaceTypeList
Unique usage	interfaceTypeList
unique var 	interfaceMemberDeclaration
Unique usage	interfaceMemberDeclaration
unique var 	interfaceDeclaration
unique var 	annotationTypeBody
Unique usage	annotationTypeBody
unique var 	annotationTypeMemberDeclaration
Unique usage	annotationTypeMemberDeclaration
unique var2 	annotationTypeElementDeclaration
unique var 	interfaceDeclaration
unique var2 	normalAnnotation
unique var2 	singleElementAnnotation
unique var 	elementValuePairList
Unique usage	elementValuePairList
unique var 	elementValuePair
Unique usage	elementValuePair
unique var 	elementValuePair
Unique usage	elementValuePair
unique var 	elementValue
unique var 	elementValue
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var2 	basicForStatement
unique var2 	enhancedForStatement
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var 	parExpression
unique var2 	tryStatement
unique var 	parExpression
unique var 	switchBlock
Unique usage	switchBlock
unique var 	block
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	switchLabel
unique var 	enumConstantName
Unique usage	enumConstantName
unique var 	expression
unique var 	forUpdate
Unique usage	forUpdate
unique var 	statement
unique var 	statementExpressionList
unique var 	statement
unique var 	block
unique var 	catchClause
Unique usage	catchClause
unique var 	resourceSpecification
Unique usage	resourceSpecification
unique var 	block
unique var 	catchClause
Unique usage	catchClause
unique var 	finally
Unique usage	finally
unique var 	catchFormalParameter
Unique usage	catchFormalParameter
unique var 	block
unique var 	variableModifier
unique var 	catchType
Unique usage	catchType
unique var 	variableDeclaratorId
unique var 	unannClassType
unique var 	classType
unique var 	block
unique var 	resourceList
Unique usage	resourceList
unique var 	resource
Unique usage	resource
unique var 	resource
Unique usage	resource
unique var 	variableModifier
unique var 	unannType
unique var 	variableDeclaratorId
unique var 	expression
unique var 	arguments
unique var 	arrayCreator
Unique usage	arrayCreator
unique var 	arguments
unique var 	arguments
unique var 	typeArguments
unique var 	arguments
unique var 	arguments
unique var 	classTypeWithDiamond
Unique usage	classTypeWithDiamond
unique var 	arguments
unique var 	classBody
Unique usage	classBody
unique var 	annotation
unique var 	typeArgumentsOrDiamond
Unique usage	typeArgumentsOrDiamond
unique var 	annotation
unique var 	typeArgumentsOrDiamond
Unique usage	typeArgumentsOrDiamond
unique var2 	dimExpr
unique var 	type
unique var 	dim
unique var 	arrayInitializer
unique var 	expression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var2 	castExpression
unique var 	unaryExpression
unique var 	lambdaExpression
unique var 	unaryExpressionNotPlusMinus
unique var 	unaryExpression
unique var 	referenceType
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	lambdaBody
Unique usage	lambdaBody
unique var 	expression
unique var 	block
foi true22
UniqueFlwVar	compilationUnit	rule = 	compilation	pref = 	__SKIP	flw = 	$
UniqueFlwVar	annotation	rule = 	primitiveType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, assert, case, default, do, else, extends, instanceof, new, query, return, super, throw, {, }, ~	flw = 	@, boolean, byte, char, double, float, int, long, short
UniqueFlwVar	primitiveType	rule = 	referenceType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, extends, instanceof, query, return, super, throw, {, }, ~	flw = 	), ,, :, ::, ;, >, @, [, ], __Identifier, __InfixOperator, and, instanceof, query, }
UniqueFlwVar	annotation	rule = 	classType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, and, assert, case, default, do, else, extends, implements, instanceof, new, query, return, super, throw, throws, {, |, }, ~	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classType	pref = 	), ., __Identifier	flw = 	@, __Identifier
passou três	primitiveType	type
UniqueFlwVar	primitiveType	rule = 	arrayType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	::, @, [
UniqueFlwVar	annotation	rule = 	typeVariable	pref = 	), ,, __Identifier, extends, throws	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	dim	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	@, [
UniqueFlwVar	typeParameterModifier	rule = 	typeParameter	pref = 	), ,, <, __Identifier	flw = 	@, __Identifier
foi true22
passou três	classType	additionalBound
UniqueFlwVar	annotation	rule = 	wildcard	pref = 	), ,, <, __Identifier	flw = 	?, @
foi true22
foi true22
foi true22
passou três	referenceType	wildcardBounds
UniqueFlwVar	packageModifier	rule = 	packageDeclaration	pref = 	), __Identifier, __SKIP	flw = 	@, package
foi true22
foi true22
foi true22
foi true22
foi true22
foi true22
UniqueFlwVar	typeParameters	rule = 	normalClassDeclaration	pref = 	__Identifier	flw = 	extends, implements, {
UniqueFlwVar	superclass	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	implements, {
UniqueFlwVar	superinterfaces	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
passou três	interfaceTypeList	superinterfaces
UniqueFlwVar	annotation	rule = 	unannClassType	pref = 	), ., __Identifier	flw = 	@, __Identifier
UniqueFlwVar	basicType	rule = 	unannType	pref = 	(, ), ,, :, ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, transient, volatile, {, }	flw = 	..., @, [, __Identifier, this
UniqueFlwVar	annotation	rule = 	methodHeader	pref = 	), >, __Identifier	flw = 	@, __Identifier, boolean, byte, char, double, float, int, long, short, void
UniqueFlwVar	annotation	rule = 	formalParameter	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	..., @
foi true22
passou três	variableDeclaratorId	formalParameter
UniqueFlwVar	variableDeclaratorId	rule = 	formalParameter	pref = 	...	flw = 	), ,
UniqueFlw	__void	rule = 	result	pref = 	), ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, {, }	flw = 	__Identifier	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlw	__synchronized	rule = 	methodModifier	pref = 	), ;, __Identifier, abstract, final, native, private, protected, public, static, stictfp, synchronized, {, }	flw = 	<, @, __Identifier, abstract, boolean, byte, char, double, final, float, int, long, native, private, protected, public, short, static, stictfp, synchronized, void	nInt = 	1	nEq = 	0	pflw = 	nil
foi true22
UniqueFlwVar	exceptionType	rule = 	exceptionTypeList	pref = 	throws	flw = 	,, ;, {
passou três	block	staticInitializer
UniqueFlwVar	throws	rule = 	constructorDeclaration	pref = 	)	flw = 	{
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	this
passou três	arguments	explicitConstructorInvocation
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	this	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
foi true22
foi true22
UniqueFlwVar	superinterfaces	rule = 	enumDeclaration	pref = 	__Identifier	flw = 	{
UniqueFlwVar	enumConstantModifier	rule = 	enumConstant	pref = 	), ,, __Identifier, {	flw = 	@, __Identifier
foi true22
UniqueFlwVar	typeParameters	rule = 	normalInterfaceDeclaration	pref = 	__Identifier	flw = 	extends, {
UniqueFlwVar	extendsInterfaces	rule = 	normalInterfaceDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
UniqueFlwVar	defaultValue	rule = 	annotationTypeElementDeclaration	pref = 	), ]	flw = 	;
passou três	markerAnnotation	annotation
UniqueFlwVar	qualIdent	rule = 	normalAnnotation	pref = 	@	flw = 	(
UniqueFlwVar	qualIdent	rule = 	singleElementAnnotation	pref = 	@	flw = 	(
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	if	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	statement	rule = 	statement	pref = 	do	flw = 	while
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	;
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	switch	flw = 	{
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	synchronized	flw = 	{
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	return	flw = 	;
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	throw	flw = 	;
foi true22
foi true22
foi true22
foi true22
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	assert	flw = 	:, ;
UniqueFlwVar	expression	rule = 	statement	pref = 	:	flw = 	;
UniqueFlwVar	primary	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
UniqueFlwVar	qualIdent	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
foi true22
UniqueFlwVar	forInit	rule = 	basicForStatement	pref = 	(	flw = 	;
UniqueFlwVar	expression	rule = 	basicForStatement	pref = 	;	flw = 	;
UniqueFlwVar	expression	rule = 	enhancedForStatement	pref = 	:	flw = 	)
foi true22
passou três	block	tryStatement
UniqueFlwVar	block	rule = 	tryStatement	pref = 	try	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	catch, finally
UniqueFlwVar	resourceSpecification	rule = 	tryStatement	pref = 	try	flw = 	{
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
foi true22
foi true22
foi true22
passou três	classType	catchType
foi true22
passou três	block	finally
foi true22
UniqueFlw	__this	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	), ++, ,, --, ., :, ::, ;, [, ], __AssignmentOperator, __Identifier, __InfixOperator, instanceof, query, }	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	expression	rule = 	primaryBase	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	basicType	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	., [
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	new
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	.	flw = 	__Identifier
UniqueFlwVar	expression	rule = 	primaryRest	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	::	flw = 	__Identifier
passou três	typeArguments	classCreator
UniqueFlwVar	typeArguments	rule = 	classCreator	pref = 	new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classCreator	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	typeArgumentsOrDiamond	rule = 	classTypeWithDiamond	pref = 	__Identifier	flw = 	(, .
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), ., __Identifier	flw = 	@, __Identifier
foi true22
UniqueFlwVar	type	rule = 	arrayCreator	pref = 	new	flw = 	@, [, {
UniqueFlwVar	annotation	rule = 	dimExpr	pref = 	), ], __Identifier	flw = 	@, [
UniqueFlwVar	expression	rule = 	dimExpr	pref = 	[	flw = 	]
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
UniqueFlwVar	primitiveType	rule = 	castExpression	pref = 	(	flw = 	)
foi true22
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
foi true22
passou três	unaryExpression	infixExpression
foi true22
passou três	referenceType	infixExpression
foi true22
passou três	expression	conditionalExpression
UniqueFlwVar	expression	rule = 	conditionalExpression	pref = 	query	flw = 	:
UniqueFlwVar	leftHandSide	rule = 	assignment	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, do, else, query, return, throw, {, }	flw = 	__AssignmentOperator
foi true22
passou três	expression	assignment
UniqueFlwVar	lambdaParameters	rule = 	lambdaExpression	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->
foi true22
UniqueFlw	Identifier	rule = 	lambdaParameters	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->	nInt = 	17	nEq = 	3	pflw = 	nil
passou três	expression	lambdaBody
passou três	block	lambdaBody
unique var 	compilationUnit
Unique usage	compilationUnit
unique var 	typeArguments
unique var 	annotation
unique var 	typeArguments
unique var 	annotation
unique var 	typeParameterModifier
Unique usage	typeParameterModifier
unique var 	typeBound
Unique usage	typeBound
unique var 	annotation
unique var 	typeVariable
Unique usage	typeVariable
unique var 	classType
unique var2 	wildcard
unique var 	wildcardBounds
Unique usage	wildcardBounds
unique var 	referenceType
unique var 	referenceType
unique var2 	packageDeclaration
unique var 	typeDeclaration
Unique usage	typeDeclaration
unique var 	qualIdent
unique var 	interfaceDeclaration
unique var2 	normalClassDeclaration
unique var2 	enumDeclaration
unique var 	typeParameters
unique var 	superclass
Unique usage	superclass
unique var 	superinterfaces
Unique usage	superinterfaces
unique var 	classBody
Unique usage	classBody
unique var2 	typeParameterList
unique var 	typeParameter
Unique usage	typeParameter
unique var 	classType
unique var 	interfaceTypeList
Unique usage	interfaceTypeList
unique var 	classType
unique var 	classType
unique var 	classBodyDeclaration
Unique usage	classBodyDeclaration
unique var 	instanceInitializer
Unique usage	instanceInitializer
unique var 	staticInitializer
Unique usage	staticInitializer
unique var 	constructorDeclaration
Unique usage	constructorDeclaration
unique var 	typeArguments
unique var 	methodDeclarator
unique var 	throws
unique var 	variableDeclaratorId
unique var 	exceptionTypeList
Unique usage	exceptionTypeList
unique var 	exceptionType
Unique usage	exceptionType
unique var 	exceptionType
Unique usage	exceptionType
unique var 	typeVariable
Unique usage	typeVariable
unique var 	block
unique var 	block
unique var 	constructorModifier
Unique usage	constructorModifier
unique var 	constructorDeclarator
Unique usage	constructorDeclarator
unique var 	throws
unique var 	constructorBody
Unique usage	constructorBody
unique var 	typeParameters
unique var 	formalParameterList
unique var 	annotation
unique var2 	explicitConstructorInvocation
unique var 	blockStatements
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	superinterfaces
Unique usage	superinterfaces
unique var 	enumBody
Unique usage	enumBody
unique var 	enumConstantList
Unique usage	enumConstantList
unique var 	enumBodyDeclarations
Unique usage	enumBodyDeclarations
unique var 	enumConstant
Unique usage	enumConstant
unique var 	enumConstantModifier
Unique usage	enumConstantModifier
unique var 	arguments
unique var 	classBody
Unique usage	classBody
unique var 	annotation
unique var 	classBodyDeclaration
Unique usage	classBodyDeclaration
unique var2 	normalInterfaceDeclaration
unique var2 	annotationTypeDeclaration
unique var 	typeParameters
unique var 	extendsInterfaces
Unique usage	extendsInterfaces
unique var 	interfaceBody
Unique usage	interfaceBody
unique var 	interfaceTypeList
Unique usage	interfaceTypeList
unique var 	interfaceMemberDeclaration
Unique usage	interfaceMemberDeclaration
unique var 	interfaceDeclaration
unique var 	annotationTypeBody
Unique usage	annotationTypeBody
unique var 	annotationTypeMemberDeclaration
Unique usage	annotationTypeMemberDeclaration
unique var2 	annotationTypeElementDeclaration
unique var 	interfaceDeclaration
unique var2 	normalAnnotation
unique var2 	singleElementAnnotation
unique var 	elementValuePairList
Unique usage	elementValuePairList
unique var 	elementValuePair
Unique usage	elementValuePair
unique var 	elementValuePair
Unique usage	elementValuePair
unique var 	elementValue
unique var 	elementValue
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var2 	basicForStatement
unique var2 	enhancedForStatement
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var 	parExpression
unique var2 	tryStatement
unique var 	parExpression
unique var 	switchBlock
Unique usage	switchBlock
unique var 	block
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	switchLabel
unique var 	enumConstantName
Unique usage	enumConstantName
unique var 	expression
unique var 	forUpdate
Unique usage	forUpdate
unique var 	statement
unique var 	statementExpressionList
unique var 	statement
unique var 	block
unique var 	catchClause
Unique usage	catchClause
unique var 	resourceSpecification
Unique usage	resourceSpecification
unique var 	block
unique var 	catchClause
Unique usage	catchClause
unique var 	finally
Unique usage	finally
unique var 	catchFormalParameter
Unique usage	catchFormalParameter
unique var 	block
unique var 	variableModifier
unique var 	catchType
Unique usage	catchType
unique var 	variableDeclaratorId
unique var 	unannClassType
unique var 	classType
unique var 	block
unique var 	resourceList
Unique usage	resourceList
unique var 	resource
Unique usage	resource
unique var 	resource
Unique usage	resource
unique var 	variableModifier
unique var 	unannType
unique var 	variableDeclaratorId
unique var 	expression
unique var 	arguments
unique var 	arrayCreator
Unique usage	arrayCreator
unique var 	arguments
unique var 	arguments
unique var 	typeArguments
unique var 	arguments
unique var 	arguments
unique var 	classTypeWithDiamond
Unique usage	classTypeWithDiamond
unique var 	arguments
unique var 	classBody
Unique usage	classBody
unique var 	annotation
unique var 	typeArgumentsOrDiamond
Unique usage	typeArgumentsOrDiamond
unique var 	annotation
unique var 	typeArgumentsOrDiamond
Unique usage	typeArgumentsOrDiamond
unique var2 	dimExpr
unique var 	type
unique var 	dim
unique var 	arrayInitializer
unique var 	expression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var2 	castExpression
unique var 	unaryExpression
unique var 	lambdaExpression
unique var 	unaryExpressionNotPlusMinus
unique var 	unaryExpression
unique var 	referenceType
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	lambdaBody
Unique usage	lambdaBody
unique var 	expression
unique var 	block
foi true22
UniqueFlwVar	compilationUnit	rule = 	compilation	pref = 	__SKIP	flw = 	$
UniqueFlwVar	annotation	rule = 	primitiveType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, assert, case, default, do, else, extends, instanceof, new, query, return, super, throw, {, }, ~	flw = 	@, boolean, byte, char, double, float, int, long, short
UniqueFlwVar	primitiveType	rule = 	referenceType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, extends, instanceof, query, return, super, throw, {, }, ~	flw = 	), ,, :, ::, ;, >, @, [, ], __Identifier, __InfixOperator, and, instanceof, query, }
UniqueFlwVar	annotation	rule = 	classType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, <, =, [, __AssignmentOperator, __Identifier, __InfixOperator, and, assert, case, default, do, else, extends, implements, instanceof, new, query, return, super, throw, throws, {, |, }, ~	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classType	pref = 	), ., __Identifier	flw = 	@, __Identifier
passou três	primitiveType	type
UniqueFlwVar	primitiveType	rule = 	arrayType	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	::, @, [
UniqueFlwVar	annotation	rule = 	typeVariable	pref = 	), ,, __Identifier, extends, throws	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	dim	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	@, [
UniqueFlwVar	typeParameterModifier	rule = 	typeParameter	pref = 	), ,, <, __Identifier	flw = 	@, __Identifier
foi true22
passou três	classType	additionalBound
UniqueFlwVar	annotation	rule = 	wildcard	pref = 	), ,, <, __Identifier	flw = 	?, @
foi true22
foi true22
foi true22
passou três	referenceType	wildcardBounds
UniqueFlwVar	packageModifier	rule = 	packageDeclaration	pref = 	), __Identifier, __SKIP	flw = 	@, package
foi true22
foi true22
foi true22
foi true22
foi true22
foi true22
UniqueFlwVar	typeParameters	rule = 	normalClassDeclaration	pref = 	__Identifier	flw = 	extends, implements, {
UniqueFlwVar	superclass	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	implements, {
UniqueFlwVar	superinterfaces	rule = 	normalClassDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
passou três	interfaceTypeList	superinterfaces
UniqueFlwVar	annotation	rule = 	unannClassType	pref = 	), ., __Identifier	flw = 	@, __Identifier
UniqueFlwVar	basicType	rule = 	unannType	pref = 	(, ), ,, :, ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, transient, volatile, {, }	flw = 	..., @, [, __Identifier, this
UniqueFlwVar	annotation	rule = 	methodHeader	pref = 	), >, __Identifier	flw = 	@, __Identifier, boolean, byte, char, double, float, int, long, short, void
UniqueFlwVar	annotation	rule = 	formalParameter	pref = 	), >, ], __Identifier, boolean, byte, char, double, float, int, long, short	flw = 	..., @
foi true22
passou três	variableDeclaratorId	formalParameter
UniqueFlwVar	variableDeclaratorId	rule = 	formalParameter	pref = 	...	flw = 	), ,
UniqueFlw	__void	rule = 	result	pref = 	), ;, >, __Identifier, abstract, default, final, native, private, protected, public, static, stictfp, strictfp, synchronized, {, }	flw = 	__Identifier	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlw	__synchronized	rule = 	methodModifier	pref = 	), ;, __Identifier, abstract, final, native, private, protected, public, static, stictfp, synchronized, {, }	flw = 	<, @, __Identifier, abstract, boolean, byte, char, double, final, float, int, long, native, private, protected, public, short, static, stictfp, synchronized, void	nInt = 	1	nEq = 	0	pflw = 	nil
foi true22
UniqueFlwVar	exceptionType	rule = 	exceptionTypeList	pref = 	throws	flw = 	,, ;, {
passou três	block	staticInitializer
UniqueFlwVar	throws	rule = 	constructorDeclaration	pref = 	)	flw = 	{
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	this
passou três	arguments	explicitConstructorInvocation
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	this	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	{	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
UniqueFlwVar	typeArguments	rule = 	explicitConstructorInvocation	pref = 	.	flw = 	super
UniqueFlwVar	arguments	rule = 	explicitConstructorInvocation	pref = 	super	flw = 	;
foi true22
foi true22
UniqueFlwVar	superinterfaces	rule = 	enumDeclaration	pref = 	__Identifier	flw = 	{
UniqueFlwVar	enumConstantModifier	rule = 	enumConstant	pref = 	), ,, __Identifier, {	flw = 	@, __Identifier
foi true22
UniqueFlwVar	typeParameters	rule = 	normalInterfaceDeclaration	pref = 	__Identifier	flw = 	extends, {
UniqueFlwVar	extendsInterfaces	rule = 	normalInterfaceDeclaration	pref = 	>, __Identifier	flw = 	{
foi true22
UniqueFlwVar	defaultValue	rule = 	annotationTypeElementDeclaration	pref = 	), ]	flw = 	;
passou três	markerAnnotation	annotation
UniqueFlwVar	qualIdent	rule = 	normalAnnotation	pref = 	@	flw = 	(
UniqueFlwVar	qualIdent	rule = 	singleElementAnnotation	pref = 	@	flw = 	(
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	if	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	(, ++, --, ;, @, __Identifier, __Literal, assert, boolean, break, byte, char, continue, do, double, float, for, if, int, long, new, return, short, super, switch, synchronized, this, throw, try, void, while, {
foi true22
passou três	statement	statement
UniqueFlwVar	statement	rule = 	statement	pref = 	do	flw = 	while
UniqueFlwVar	parExpression	rule = 	statement	pref = 	while	flw = 	;
foi true22
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	switch	flw = 	{
passou três	parExpression	statement
UniqueFlwVar	parExpression	rule = 	statement	pref = 	synchronized	flw = 	{
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	return	flw = 	;
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	throw	flw = 	;
foi true22
foi true22
foi true22
foi true22
foi true22
passou três	expression	statement
UniqueFlwVar	expression	rule = 	statement	pref = 	assert	flw = 	:, ;
UniqueFlwVar	expression	rule = 	statement	pref = 	:	flw = 	;
UniqueFlwVar	primary	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
UniqueFlwVar	qualIdent	rule = 	statementExpression	pref = 	(, ), ,, :, ;, do, else, {, }	flw = 	++, --
foi true22
UniqueFlwVar	forInit	rule = 	basicForStatement	pref = 	(	flw = 	;
UniqueFlwVar	expression	rule = 	basicForStatement	pref = 	;	flw = 	;
UniqueFlwVar	expression	rule = 	enhancedForStatement	pref = 	:	flw = 	)
foi true22
passou três	block	tryStatement
UniqueFlwVar	block	rule = 	tryStatement	pref = 	try	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	catch, finally
UniqueFlwVar	resourceSpecification	rule = 	tryStatement	pref = 	try	flw = 	{
UniqueFlwVar	catchClause	rule = 	tryStatement	pref = 	}	flw = 	(, ++, --, ;, @, __Identifier, __Literal, abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, final, finally, float, for, if, int, long, new, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, try, void, while, {, }
foi true22
foi true22
foi true22
passou três	classType	catchType
foi true22
passou três	block	finally
foi true22
UniqueFlw	__this	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	), ++, ,, --, ., :, ::, ;, [, ], __AssignmentOperator, __Identifier, __InfixOperator, instanceof, query, }	nInt = 	1	nEq = 	0	pflw = 	nil
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	expression	rule = 	primaryBase	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	.	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	__Identifier
foi true22
UniqueFlwVar	basicType	rule = 	primaryBase	pref = 	!, (, ), +, ++, ,, -, --, ->, :, ;, =, [, __AssignmentOperator, __InfixOperator, assert, case, default, do, else, query, return, throw, {, }, ~	flw = 	., [
UniqueFlwVar	typeArguments	rule = 	primaryBase	pref = 	::	flw = 	new
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	.	flw = 	__Identifier
UniqueFlwVar	expression	rule = 	primaryRest	pref = 	[	flw = 	]
UniqueFlwVar	typeArguments	rule = 	primaryRest	pref = 	::	flw = 	__Identifier
passou três	typeArguments	classCreator
UniqueFlwVar	typeArguments	rule = 	classCreator	pref = 	new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classCreator	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), >, __Identifier, new	flw = 	@, __Identifier
UniqueFlwVar	typeArgumentsOrDiamond	rule = 	classTypeWithDiamond	pref = 	__Identifier	flw = 	(, .
UniqueFlwVar	annotation	rule = 	classTypeWithDiamond	pref = 	), ., __Identifier	flw = 	@, __Identifier
foi true22
UniqueFlwVar	type	rule = 	arrayCreator	pref = 	new	flw = 	@, [, {
UniqueFlwVar	annotation	rule = 	dimExpr	pref = 	), ], __Identifier	flw = 	@, [
UniqueFlwVar	expression	rule = 	dimExpr	pref = 	[	flw = 	]
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpression
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
foi true22
passou três	unaryExpression	unaryExpressionNotPlusMinus
UniqueFlwVar	primitiveType	rule = 	castExpression	pref = 	(	flw = 	)
foi true22
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
UniqueFlwVar	additionalBound	rule = 	castExpression	pref = 	>, ], __Identifier	flw = 	), and
foi true22
passou três	unaryExpression	infixExpression
foi true22
passou três	referenceType	infixExpression
foi true22
passou três	expression	conditionalExpression
UniqueFlwVar	expression	rule = 	conditionalExpression	pref = 	query	flw = 	:
UniqueFlwVar	leftHandSide	rule = 	assignment	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, do, else, query, return, throw, {, }	flw = 	__AssignmentOperator
foi true22
passou três	expression	assignment
UniqueFlwVar	lambdaParameters	rule = 	lambdaExpression	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->
foi true22
UniqueFlw	Identifier	rule = 	lambdaParameters	pref = 	(, ), ,, ->, :, ;, =, [, __AssignmentOperator, assert, case, query, return, throw, {	flw = 	->	nInt = 	17	nEq = 	3	pflw = 	nil
passou três	expression	lambdaBody
passou três	block	lambdaBody
unique var 	compilationUnit
Unique usage	compilationUnit
unique var 	typeArguments
unique var 	annotation
unique var 	typeArguments
unique var 	annotation
unique var 	typeParameterModifier
Unique usage	typeParameterModifier
unique var 	typeBound
Unique usage	typeBound
unique var 	annotation
unique var 	typeVariable
Unique usage	typeVariable
unique var 	classType
unique var2 	wildcard
unique var 	wildcardBounds
Unique usage	wildcardBounds
unique var 	referenceType
unique var 	referenceType
unique var2 	packageDeclaration
unique var 	typeDeclaration
Unique usage	typeDeclaration
unique var 	qualIdent
unique var 	interfaceDeclaration
unique var2 	normalClassDeclaration
unique var2 	enumDeclaration
unique var 	typeParameters
unique var 	superclass
Unique usage	superclass
unique var 	superinterfaces
Unique usage	superinterfaces
unique var 	classBody
Unique usage	classBody
unique var2 	typeParameterList
unique var 	typeParameter
Unique usage	typeParameter
unique var 	classType
unique var 	interfaceTypeList
Unique usage	interfaceTypeList
unique var 	classType
unique var 	classType
unique var 	classBodyDeclaration
Unique usage	classBodyDeclaration
unique var 	instanceInitializer
Unique usage	instanceInitializer
unique var 	staticInitializer
Unique usage	staticInitializer
unique var 	constructorDeclaration
Unique usage	constructorDeclaration
unique var 	typeArguments
unique var 	methodDeclarator
unique var 	throws
unique var 	variableDeclaratorId
unique var 	exceptionTypeList
Unique usage	exceptionTypeList
unique var 	exceptionType
Unique usage	exceptionType
unique var 	exceptionType
Unique usage	exceptionType
unique var 	typeVariable
Unique usage	typeVariable
unique var 	block
unique var 	block
unique var 	constructorModifier
Unique usage	constructorModifier
unique var 	constructorDeclarator
Unique usage	constructorDeclarator
unique var 	throws
unique var 	constructorBody
Unique usage	constructorBody
unique var 	typeParameters
unique var 	formalParameterList
unique var 	annotation
unique var2 	explicitConstructorInvocation
unique var 	blockStatements
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	arguments
unique var 	superinterfaces
Unique usage	superinterfaces
unique var 	enumBody
Unique usage	enumBody
unique var 	enumConstantList
Unique usage	enumConstantList
unique var 	enumBodyDeclarations
Unique usage	enumBodyDeclarations
unique var 	enumConstant
Unique usage	enumConstant
unique var 	enumConstantModifier
Unique usage	enumConstantModifier
unique var 	arguments
unique var 	classBody
Unique usage	classBody
unique var 	annotation
unique var 	classBodyDeclaration
Unique usage	classBodyDeclaration
unique var2 	normalInterfaceDeclaration
unique var2 	annotationTypeDeclaration
unique var 	typeParameters
unique var 	extendsInterfaces
Unique usage	extendsInterfaces
unique var 	interfaceBody
Unique usage	interfaceBody
unique var 	interfaceTypeList
Unique usage	interfaceTypeList
unique var 	interfaceMemberDeclaration
Unique usage	interfaceMemberDeclaration
unique var 	interfaceDeclaration
unique var 	annotationTypeBody
Unique usage	annotationTypeBody
unique var 	annotationTypeMemberDeclaration
Unique usage	annotationTypeMemberDeclaration
unique var2 	annotationTypeElementDeclaration
unique var 	interfaceDeclaration
unique var2 	normalAnnotation
unique var2 	singleElementAnnotation
unique var 	elementValuePairList
Unique usage	elementValuePairList
unique var 	elementValuePair
Unique usage	elementValuePair
unique var 	elementValuePair
Unique usage	elementValuePair
unique var 	elementValue
unique var 	elementValue
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var2 	basicForStatement
unique var2 	enhancedForStatement
unique var 	parExpression
unique var 	statement
unique var 	statement
unique var 	parExpression
unique var2 	tryStatement
unique var 	parExpression
unique var 	switchBlock
Unique usage	switchBlock
unique var 	block
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	switchLabel
unique var 	enumConstantName
Unique usage	enumConstantName
unique var 	expression
unique var 	forUpdate
Unique usage	forUpdate
unique var 	statement
unique var 	statementExpressionList
unique var 	statement
unique var 	block
unique var 	catchClause
Unique usage	catchClause
unique var 	resourceSpecification
Unique usage	resourceSpecification
unique var 	block
unique var 	catchClause
Unique usage	catchClause
unique var 	finally
Unique usage	finally
unique var 	catchFormalParameter
Unique usage	catchFormalParameter
unique var 	block
unique var 	variableModifier
unique var 	catchType
Unique usage	catchType
unique var 	variableDeclaratorId
unique var 	unannClassType
unique var 	classType
unique var 	block
unique var 	resourceList
Unique usage	resourceList
unique var 	resource
Unique usage	resource
unique var 	resource
Unique usage	resource
unique var 	variableModifier
unique var 	unannType
unique var 	variableDeclaratorId
unique var 	expression
unique var 	arguments
unique var 	arrayCreator
Unique usage	arrayCreator
unique var 	arguments
unique var 	arguments
unique var 	typeArguments
unique var 	arguments
unique var 	arguments
unique var 	classTypeWithDiamond
Unique usage	classTypeWithDiamond
unique var 	arguments
unique var 	classBody
Unique usage	classBody
unique var 	annotation
unique var 	typeArgumentsOrDiamond
Unique usage	typeArgumentsOrDiamond
unique var 	annotation
unique var 	typeArgumentsOrDiamond
Unique usage	typeArgumentsOrDiamond
unique var2 	dimExpr
unique var 	type
unique var 	dim
unique var 	arrayInitializer
unique var 	expression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var 	unaryExpression
unique var2 	castExpression
unique var 	unaryExpression
unique var 	lambdaExpression
unique var 	unaryExpressionNotPlusMinus
unique var 	unaryExpression
unique var 	referenceType
unique var 	expression
unique var 	expression
unique var 	expression
unique var 	lambdaBody
Unique usage	lambdaBody
unique var 	expression
unique var 	block
insideLoop: basicType, primitiveType, referenceType, classType, arrayType, dim, typeParameterModifier, typeBound, additionalBound, typeArguments, wildcardBounds, qualIdent, packageDeclaration, packageModifier, importDeclaration, typeDeclaration, classDeclaration, normalClassDeclaration, classModifier, typeParameters, superclass, superinterfaces, classBody, classBodyDeclaration, classMemberDeclaration, fieldDeclaration, variableInitializer, unannClassType, unannType, fieldModifier, methodDeclaration, methodHeader, formalParameterList, formalParameter, variableModifier, receiverParameter, result, methodModifier, throws, instanceInitializer, staticInitializer, constructorDeclaration, constructorDeclarator, constructorModifier, explicitConstructorInvocation, enumDeclaration, enumConstantList, enumConstant, enumConstantModifier, enumBodyDeclarations, interfaceDeclaration, normalInterfaceDeclaration, interfaceModifier, extendsInterfaces, interfaceMemberDeclaration, constantDeclaration, constantModifier, interfaceMethodDeclaration, interfaceMethodModifier, annotationTypeDeclaration, annotationTypeMemberDeclaration, annotationTypeElementDeclaration, annotationTypeElementModifier, defaultValue, annotation, elementValuePairList, elementValuePair, elementValue, elementValueArrayInitializer, elementValueList, arrayInitializer, variableInitializerList, block, blockStatements, blockStatement, localVariableDeclarationStatement, localVariableDeclaration, statement, statementExpression, switchBlockStatementGroup, switchLabels, switchLabel, basicForStatement, forInit, forUpdate, statementExpressionList, enhancedForStatement, tryStatement, catchClause, finally, expression, primary, primaryBase, primaryRest, parExpression, typeArgumentsOrDiamond, dimExpr, arguments, argumentList, unaryExpression, unaryExpressionNotPlusMinus, castExpression, infixExpression, conditionalExpression, assignmentExpression, assignment, leftHandSide, lambdaExpression, lambdaParameters, 
Unique vars: compilation, typeVariable, typeParameter, typeParameterModifier, typeBound, wildcardBounds, compilationUnit, typeDeclaration, superclass, superinterfaces, interfaceTypeList, classBody, classBodyDeclaration, exceptionTypeList, exceptionType, instanceInitializer, staticInitializer, constructorDeclaration, constructorDeclarator, constructorModifier, constructorBody, enumBody, enumConstantList, enumConstant, enumConstantModifier, enumBodyDeclarations, extendsInterfaces, interfaceBody, interfaceMemberDeclaration, annotationTypeBody, annotationTypeMemberDeclaration, elementValuePairList, elementValuePair, switchBlock, enumConstantName, forUpdate, catchClause, catchFormalParameter, catchType, finally, resourceSpecification, resourceList, resource, classTypeWithDiamond, typeArgumentsOrDiamond, arrayCreator, lambdaBody, 
matchUPath: compilation, basicType, primitiveType, classType, typeVariable, dim, typeParameter, typeParameterModifier, typeBound, additionalBound, wildcard, wildcardBounds, compilationUnit, packageDeclaration, typeDeclaration, classDeclaration, normalClassDeclaration, typeParameters, typeParameterList, superclass, superinterfaces, interfaceTypeList, classBody, classBodyDeclaration, throws, exceptionTypeList, exceptionType, instanceInitializer, staticInitializer, constructorDeclaration, constructorDeclarator, constructorModifier, constructorBody, explicitConstructorInvocation, enumDeclaration, enumBody, enumConstantList, enumConstant, enumConstantModifier, enumBodyDeclarations, interfaceDeclaration, normalInterfaceDeclaration, extendsInterfaces, interfaceBody, interfaceMemberDeclaration, annotationTypeDeclaration, annotationTypeBody, annotationTypeMemberDeclaration, annotationTypeElementDeclaration, annotation, normalAnnotation, elementValuePairList, elementValuePair, singleElementAnnotation, switchBlock, switchLabel, enumConstantName, basicForStatement, forUpdate, enhancedForStatement, tryStatement, catchClause, catchFormalParameter, catchType, finally, resourceSpecification, resourceList, resource, classCreator, classTypeWithDiamond, typeArgumentsOrDiamond, arrayCreator, dimExpr, castExpression, assignment, lambdaExpression, lambdaBody, 
Adding labels: Err_1, Err_2, Err_3, Err_4, Err_5, Err_6, Err_7, Err_8, Err_9, Err_10, Err_11, Err_12, Err_13, Err_14, Err_15, Err_16, Err_17, Err_18, Err_19, Err_20, Err_21, Err_22, Err_23, Err_24, Err_25, Err_26, Err_27, Err_28, Err_29, Err_30, Err_31, Err_32, Err_33, Err_34, Err_35, Err_36, Err_37, Err_38, Err_39, Err_40, Err_41, Err_42, Err_43, Err_44, Err_45, Err_46, Err_47, Err_48, Err_49, Err_50, Err_51, Err_52, Err_53, Err_54, Err_55, Err_56, Err_57, Err_58, Err_59, Err_60, Err_61, Err_62, Err_63, Err_64, Err_65, Err_66, Err_67, Err_68, Err_69, Err_70, Err_71, Err_72, Err_73, Err_74, Err_75, Err_76, Err_77, Err_78, Err_79, Err_80, Err_81, Err_82, Err_83, Err_84, Err_85, Err_86, Err_87, Err_88, Err_89, Err_90, Err_91, Err_92, Err_93, Err_94, Err_95, Err_96, Err_97, Err_98, Err_99, Err_100, Err_101, Err_102, Err_103, Err_104, Err_105, Err_106, Err_107, Err_108, Err_109, Err_110, Err_111, Err_112, Err_113, Err_114, Err_115, Err_116, Err_117, Err_118, Err_119, Err_120, Err_121, Err_122, Err_123, Err_124, Err_125, Err_126, Err_127, Err_128, Err_129, Err_130, Err_131, Err_132, Err_133, Err_134, Err_135, Err_136, Err_137, Err_138, Err_139, Err_140, Err_141, Err_142, Err_143, Err_144, Err_145, Err_146, Err_147, Err_148, Err_149, Err_150, 

Property 	nil
compilation     <-  SKIP compilationUnit !.
basicType       <-  'byte'  /  'short'  /  'int'  /  'long'  /  'char'  /  'float'  /  'double'  /  'boolean'
primitiveType   <-  annotation* basicType
referenceType   <-  primitiveType dim+  /  classType dim*
classType       <-  annotation* Identifier typeArguments? ('.' annotation* Identifier^Err_001 typeArguments?)*
type            <-  primitiveType  /  classType
arrayType       <-  primitiveType dim+  /  classType dim+
typeVariable    <-  annotation* Identifier^Err_002
dim             <-  annotation* '[' ']'^Err_003
typeParameter   <-  typeParameterModifier* Identifier^Err_004 typeBound?
typeParameterModifier <-  annotation
typeBound       <-  'extends' (classType additionalBound*  /  typeVariable)^Err_005
additionalBound <-  'and' classType^Err_006
typeArguments   <-  '<' typeArgumentList '>'
typeArgumentList <-  typeArgument (',' typeArgument)*
typeArgument    <-  referenceType  /  wildcard
wildcard        <-  annotation* '?' wildcardBounds?
wildcardBounds  <-  'extends' referenceType^Err_007  /  'super' referenceType^Err_008
qualIdent       <-  Identifier ('.' Identifier)*
compilationUnit <-  packageDeclaration? importDeclaration* typeDeclaration*
packageDeclaration <-  packageModifier* 'package' Identifier^Err_009 ('.' Identifier^Err_010)* ';'^Err_011
packageModifier <-  annotation
importDeclaration <-  'import' 'static'? qualIdent^Err_012 ('.' '*'^Err_013)? ';'^Err_014  /  ';'
typeDeclaration <-  classDeclaration  /  interfaceDeclaration  /  ';'
classDeclaration <-  normalClassDeclaration  /  enumDeclaration
normalClassDeclaration <-  classModifier* 'class' Identifier^Err_015 typeParameters? superclass? superinterfaces? classBody^Err_016
classModifier   <-  annotation  /  'public'  /  'protected'  /  'private'  /  'abstract'  /  'static'  /  'final'  /  'strictfp'
typeParameters  <-  '<' typeParameterList '>'^Err_017
typeParameterList <-  typeParameter (',' typeParameter^Err_018)*
superclass      <-  'extends' classType^Err_019
superinterfaces <-  'implements' interfaceTypeList^Err_020
interfaceTypeList <-  classType^Err_021 (',' classType^Err_022)*
classBody       <-  '{' classBodyDeclaration* '}'^Err_023
classBodyDeclaration <-  classMemberDeclaration  /  instanceInitializer  /  staticInitializer  /  constructorDeclaration
classMemberDeclaration <-  fieldDeclaration  /  methodDeclaration  /  classDeclaration  /  interfaceDeclaration  /  ';'
fieldDeclaration <-  fieldModifier* unannType variableDeclaratorList ';'
variableDeclaratorList <-  variableDeclarator (',' variableDeclarator)*
variableDeclarator <-  variableDeclaratorId ('=' !'=' variableInitializer)?
variableDeclaratorId <-  Identifier dim*
variableInitializer <-  expression  /  arrayInitializer
unannClassType  <-  Identifier typeArguments? ('.' annotation* Identifier typeArguments?)*
unannType       <-  basicType dim*  /  unannClassType dim*
fieldModifier   <-  annotation  /  'public'  /  'protected'  /  'private'  /  'static'  /  'final'  /  'transient'  /  'volatile'
methodDeclaration <-  methodModifier* methodHeader methodBody
methodHeader    <-  result methodDeclarator throws?  /  typeParameters annotation* result methodDeclarator^Err_024 throws?
methodDeclarator <-  Identifier '(' formalParameterList? ')' dim*
formalParameterList <-  (receiverParameter  /  formalParameter) (',' formalParameter)*
formalParameter <-  variableModifier* unannType variableDeclaratorId  /  variableModifier* unannType annotation* '...' variableDeclaratorId^Err_025 !','
variableModifier <-  annotation  /  'final'
receiverParameter <-  variableModifier* unannType (Identifier '.')? 'this'
result          <-  unannType  /  'void'
methodModifier  <-  annotation  /  'public'  /  'protected'  /  'private'  /  'abstract'  /  'static'  /  'final'  /  'synchronized'  /  'native'  /  'stictfp'
throws          <-  'throws' exceptionTypeList^Err_026
exceptionTypeList <-  exceptionType^Err_027 (',' exceptionType^Err_028)*
exceptionType   <-  (classType  /  typeVariable)^Err_029
methodBody      <-  block  /  ';'
instanceInitializer <-  block
staticInitializer <-  'static' block^Err_030
constructorDeclaration <-  constructorModifier* constructorDeclarator throws? constructorBody^Err_031
constructorDeclarator <-  typeParameters? Identifier '('^Err_032 formalParameterList? ')'^Err_033
constructorModifier <-  annotation  /  'public'  /  'protected'  /  'private'
constructorBody <-  '{'^Err_034 explicitConstructorInvocation? blockStatements? '}'^Err_035
explicitConstructorInvocation <-  typeArguments? 'this' arguments^Err_036 ';'^Err_037  /  typeArguments? 'super' arguments^Err_038 ';'^Err_039  /  primary '.' typeArguments? 'super' arguments^Err_040 ';'^Err_041  /  qualIdent '.' typeArguments? 'super' arguments^Err_042 ';'^Err_043
enumDeclaration <-  classModifier* 'enum' Identifier^Err_044 superinterfaces? enumBody^Err_045
enumBody        <-  '{'^Err_046 enumConstantList? ','? enumBodyDeclarations? '}'^Err_047
enumConstantList <-  enumConstant (',' enumConstant)*
enumConstant    <-  enumConstantModifier* Identifier arguments? classBody?
enumConstantModifier <-  annotation
enumBodyDeclarations <-  ';' classBodyDeclaration*
interfaceDeclaration <-  normalInterfaceDeclaration  /  annotationTypeDeclaration
normalInterfaceDeclaration <-  interfaceModifier* 'interface' Identifier^Err_048 typeParameters? extendsInterfaces? interfaceBody^Err_049
interfaceModifier <-  annotation  /  'public'  /  'protected'  /  'private'  /  'abstract'  /  'static'  /  'strictfp'
extendsInterfaces <-  'extends' interfaceTypeList^Err_050
interfaceBody   <-  '{'^Err_051 interfaceMemberDeclaration* '}'^Err_052
interfaceMemberDeclaration <-  constantDeclaration  /  interfaceMethodDeclaration  /  classDeclaration  /  interfaceDeclaration  /  ';'
constantDeclaration <-  constantModifier* unannType variableDeclaratorList ';'
constantModifier <-  annotation  /  'public'  /  'static'  /  'final'
interfaceMethodDeclaration <-  interfaceMethodModifier* methodHeader methodBody
interfaceMethodModifier <-  annotation  /  'public'  /  'abstract'  /  'default'  /  'static'  /  'strictfp'
annotationTypeDeclaration <-  interfaceModifier* '@' 'interface' Identifier^Err_053 annotationTypeBody^Err_054
annotationTypeBody <-  '{'^Err_055 annotationTypeMemberDeclaration* '}'^Err_056
annotationTypeMemberDeclaration <-  annotationTypeElementDeclaration  /  constantDeclaration  /  classDeclaration  /  interfaceDeclaration  /  ';'
annotationTypeElementDeclaration <-  annotationTypeElementModifier* unannType Identifier '(' ')' dim* defaultValue? ';'
annotationTypeElementModifier <-  annotation  /  'public'  /  'abstract'
defaultValue    <-  'default' elementValue
annotation      <-  '@' (normalAnnotation  /  singleElementAnnotation  /  markerAnnotation)
normalAnnotation <-  qualIdent '(' elementValuePairList* ')'^Err_057
elementValuePairList <-  elementValuePair (',' elementValuePair^Err_058)*
elementValuePair <-  Identifier '='^Err_059 !'=' elementValue^Err_060
elementValue    <-  conditionalExpression  /  elementValueArrayInitializer  /  annotation
elementValueArrayInitializer <-  '{' elementValueList? ','? '}'
elementValueList <-  elementValue (',' elementValue)*
markerAnnotation <-  qualIdent
singleElementAnnotation <-  qualIdent '(' elementValue^Err_061 ')'^Err_062
arrayInitializer <-  '{' variableInitializerList? ','? '}'
variableInitializerList <-  variableInitializer (',' variableInitializer)*
block           <-  '{' blockStatements? '}'
blockStatements <-  blockStatement blockStatement*
blockStatement  <-  localVariableDeclarationStatement  /  classDeclaration  /  statement
localVariableDeclarationStatement <-  localVariableDeclaration ';'
localVariableDeclaration <-  variableModifier* unannType variableDeclaratorList
statement       <-  block  /  'if' parExpression^Err_063 statement^Err_064 ('else' statement^Err_065)?  /  basicForStatement  /  enhancedForStatement  /  'while' parExpression^Err_066 statement^Err_067  /  'do' statement^Err_068 'while'^Err_069 parExpression^Err_070 ';'^Err_071  /  tryStatement  /  'switch' parExpression^Err_072 switchBlock^Err_073  /  'synchronized' parExpression block^Err_074  /  'return' expression? ';'^Err_075  /  'throw' expression^Err_076 ';'^Err_077  /  'break' Identifier? ';'^Err_078  /  'continue' Identifier? ';'^Err_079  /  'assert' expression^Err_080 (':' expression^Err_081)? ';'^Err_082  /  ';'  /  statementExpression ';'  /  Identifier ':' statement
statementExpression <-  assignment  /  ('++'  /  '--') (primary  /  qualIdent)  /  (primary  /  qualIdent) ('++'  /  '--')  /  primary
switchBlock     <-  '{'^Err_083 switchBlockStatementGroup* switchLabel* '}'^Err_084
switchBlockStatementGroup <-  switchLabels blockStatements
switchLabels    <-  switchLabel switchLabel*
switchLabel     <-  'case' (constantExpression  /  enumConstantName)^Err_085 ':'^Err_086  /  'default' ':'
enumConstantName <-  Identifier^Err_087
basicForStatement <-  'for' '('^Err_088 forInit? ';' expression? ';'^Err_089 forUpdate? ')'^Err_090 statement^Err_091
forInit         <-  localVariableDeclaration  /  statementExpressionList
forUpdate       <-  statementExpressionList
statementExpressionList <-  statementExpression (',' statementExpression)*
enhancedForStatement <-  'for' '('^Err_092 variableModifier* unannType variableDeclaratorId ':' expression ')' statement^Err_093
tryStatement    <-  'try' (block (catchClause* finally  /  catchClause+)^Err_094  /  resourceSpecification block^Err_095 catchClause* finally?)^Err_096
catchClause     <-  'catch' '('^Err_097 catchFormalParameter^Err_098 ')'^Err_099 block^Err_100
catchFormalParameter <-  variableModifier* catchType^Err_101 variableDeclaratorId^Err_102
catchType       <-  unannClassType^Err_103 ('|' ![=|] classType^Err_104)*
finally         <-  'finally' block^Err_105
resourceSpecification <-  '('^Err_106 resourceList^Err_107 ';'? ')'^Err_108
resourceList    <-  resource^Err_109 (',' resource^Err_110)*
resource        <-  variableModifier* unannType^Err_111 variableDeclaratorId^Err_112 '='^Err_113 !'=' expression^Err_114
expression      <-  lambdaExpression  /  assignmentExpression
primary         <-  primaryBase primaryRest*
primaryBase     <-  'this'  /  Literal  /  parExpression  /  'super' ('.' typeArguments? Identifier arguments^Err_115  /  '.' Identifier  /  '::' typeArguments? Identifier)  /  'new' (classCreator  /  arrayCreator)^Err_116  /  qualIdent ('[' expression ']'  /  arguments  /  '.' ('this'  /  'new' classCreator^Err_117  /  typeArguments Identifier arguments^Err_118  /  'super' '.' typeArguments? Identifier arguments^Err_119  /  'super' '.' Identifier  /  'super' '::' typeArguments? Identifier^Err_120 arguments^Err_121)  /  ('[' ']')* '.' 'class'  /  '::' typeArguments? Identifier)  /  'void' '.' 'class'^Err_122  /  basicType ('[' ']')* '.'^Err_123 'class'^Err_124  /  referenceType '::' typeArguments? 'new'  /  arrayType '::' 'new'
primaryRest     <-  '.' (typeArguments? Identifier arguments^Err_125  /  Identifier  /  'new' classCreator^Err_126)  /  '[' expression ']'  /  '::' typeArguments? Identifier
parExpression   <-  '(' expression ')'
classCreator    <-  typeArguments? annotation* classTypeWithDiamond arguments^Err_127 classBody?
classTypeWithDiamond <-  annotation* Identifier^Err_128 typeArgumentsOrDiamond? ('.' annotation* Identifier^Err_129 typeArgumentsOrDiamond?)*
typeArgumentsOrDiamond <-  typeArguments  /  '<' '>'^Err_130 !'.'
arrayCreator    <-  (type dimExpr+ dim*  /  type dim+^Err_131 arrayInitializer^Err_132)^Err_133
dimExpr         <-  annotation* '[' expression^Err_134 ']'^Err_135
arguments       <-  '(' argumentList? ')'
argumentList    <-  expression (',' expression)*
unaryExpression <-  ('++'  /  '--') (primary  /  qualIdent)  /  '+' ![=+] unaryExpression^Err_136  /  '-' ![-=>] unaryExpression^Err_137  /  unaryExpressionNotPlusMinus
unaryExpressionNotPlusMinus <-  '~' unaryExpression^Err_138  /  '!' ![=&] unaryExpression^Err_139  /  castExpression  /  (primary  /  qualIdent) ('++'  /  '--')?
castExpression  <-  '(' primitiveType ')' unaryExpression^Err_140  /  '(' referenceType additionalBound* ')' lambdaExpression^Err_141  /  '(' referenceType additionalBound* ')' unaryExpressionNotPlusMinus^Err_142
infixExpression <-  unaryExpression (InfixOperator unaryExpression^Err_143  /  'instanceof' referenceType^Err_144)*
InfixOperator   <-  '||'  /  '&&'  /  '|' ![=|]  /  '^' ![=]  /  '&' ![=&]  /  '=='  /  '!='  /  '<' ![=<]  /  '>' ![=>]  /  '<='  /  '>='  /  '<<' ![=]  /  '>>' ![=>]  /  '>>>' ![=]  /  '+' ![=+]  /  '-' ![-=>]  /  '*' ![=]  /  '/' ![=]  /  '%' ![=]
conditionalExpression <-  infixExpression ('query' expression^Err_145 ':'^Err_146 expression^Err_147)*
assignmentExpression <-  assignment  /  conditionalExpression
assignment      <-  leftHandSide AssignmentOperator expression^Err_148
leftHandSide    <-  primary  /  qualIdent
AssignmentOperator <-  '=' ![=]  /  '*='  /  '/='  /  '%='  /  '+='  /  '-='  /  '<<='  /  '>>='  /  '>>>='  /  '&='  /  '^='  /  '|='
lambdaExpression <-  lambdaParameters '->' lambdaBody^Err_149
lambdaParameters <-  Identifier  /  '(' formalParameterList? ')'  /  '(' inferredFormalParameterList ')'
inferredFormalParameterList <-  Identifier (',' Identifier)*
lambdaBody      <-  (expression  /  block)^Err_150
constantExpression <-  expression
Identifier      <-  !Keywords [a-zA-Z_] [a-zA-Z_$0-9]*
Keywords        <-  ('abstract'  /  'assert'  /  'boolean'  /  'break'  /  'byte'  /  'case'  /  'catch'  /  'char'  /  'class'  /  'const'  /  'continue'  /  'default'  /  'double'  /  'do'  /  'else'  /  'enum'  /  'extends'  /  'false'  /  'finally'  /  'final'  /  'float'  /  'for'  /  'goto'  /  'if'  /  'implements'  /  'import'  /  'interface'  /  'int'  /  'instanceof'  /  'long'  /  'native'  /  'new'  /  'null'  /  'package'  /  'private'  /  'protected'  /  'public'  /  'return'  /  'short'  /  'static'  /  'strictfp'  /  'super'  /  'switch'  /  'synchronized'  /  'this'  /  'throws'  /  'throw'  /  'transient'  /  'true'  /  'try'  /  'void'  /  'volatile'  /  'while') ![a-zA-Z_$0-9]
Literal         <-  FloatLiteral  /  IntegerLiteral  /  BooleanLiteral  /  CharLiteral  /  StringLiteral  /  NullLiteral
IntegerLiteral  <-  (HexNumeral  /  BinaryNumeral  /  OctalNumeral  /  DecimalNumeral) [lL]?
DecimalNumeral  <-  '0'  /  [1-9] ([_]* [0-9])*
HexNumeral      <-  ('0x'  /  '0X') HexDigits
OctalNumeral    <-  '0' ([_]* [0-7])+
BinaryNumeral   <-  ('0b'  /  '0B') [01] ([_]* [01])*
FloatLiteral    <-  HexaDecimalFloatingPointLiteral  /  DecimalFloatingPointLiteral
DecimalFloatingPointLiteral <-  Digits '.' Digits? Exponent? [fFdD]?  /  '.' Digits Exponent? [fFdD]?  /  Digits Exponent [fFdD]?  /  Digits Exponent? [fFdD]
Exponent        <-  [eE] [-+]? Digits
HexaDecimalFloatingPointLiteral <-  HexSignificand BinaryExponent [fFdD]?
HexSignificand  <-  ('0x'  /  '0X') HexDigits? '.' HexDigits  /  HexNumeral '.'?
HexDigits       <-  HexDigit ([_]* HexDigit)*
HexDigit        <-  [a-f]  /  [A-F]  /  [0-9]
BinaryExponent  <-  [pP] [-+]? Digits
Digits          <-  [0-9] ([_]* [0-9])*
BooleanLiteral  <-  'true'  /  'false'
CharLiteral     <-  "'" (%nl  /  !"'" .) "'"
StringLiteral   <-  '"' (%nl  /  !'"' .)* '"'
NullLiteral     <-  'null'
COMMENT         <-  '//' (!%nl .)*  /  '/*' (!'*/' .)* '*/'
SPACE           <-  [ 	
]  /  COMMENT
SKIP            <-  ([ 	
]  /  COMMENT)*
Token           <-  '~'  /  '}'  /  '{'  /  'stictfp'  /  'query'  /  'and'  /  StringLiteral  /  OctalNumeral  /  NullLiteral  /  Literal  /  Keywords  /  IntegerLiteral  /  InfixOperator  /  Identifier  /  HexaDecimalFloatingPointLiteral  /  HexSignificand  /  HexNumeral  /  HexDigits  /  HexDigit  /  FloatLiteral  /  Exponent  /  Digits  /  DecimalNumeral  /  DecimalFloatingPointLiteral  /  CharLiteral  /  COMMENT  /  BooleanLiteral  /  BinaryNumeral  /  BinaryExponent  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  '?'  /  ';'  /  '::'  /  ':'  /  '...'  /  '->'  /  '--'  /  ','  /  '++'  /  ')'  /  '('  /  '!'
EatToken        <-  (Token  /  (!SPACE .)+) SKIP
Err_001         <-  (!('}'  /  '|'  /  '{'  /  'query'  /  'instanceof'  /  'implements'  /  'and'  /  InfixOperator  /  Identifier  /  ']'  /  '['  /  '@'  /  '>'  /  '<'  /  ';'  /  '::'  /  ':'  /  '.'  /  ','  /  ')') EatToken)*
Err_002         <-  (!('{'  /  '>'  /  ';'  /  ',') EatToken)*
Err_003         <-  (!('}'  /  '{'  /  'throws'  /  'this'  /  'query'  /  'instanceof'  /  'default'  /  'and'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  '>'  /  '='  /  ';'  /  '::'  /  ':'  /  '...'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_004         <-  (!('extends'  /  '>'  /  ',') EatToken)*
Err_005         <-  (!('>'  /  ',') EatToken)*
Err_006         <-  (!('and'  /  '>'  /  ','  /  ')') EatToken)*
Err_007         <-  (!('>'  /  ',') EatToken)*
Err_008         <-  (!('>'  /  ',') EatToken)*
Err_009         <-  (!(';'  /  '.') EatToken)*
Err_010         <-  (!(';'  /  '.') EatToken)*
Err_011         <-  (!('strictfp'  /  'static'  /  'public'  /  'protected'  /  'private'  /  'interface'  /  'import'  /  'final'  /  'enum'  /  'class'  /  'abstract'  /  '@'  /  ';'  /  !.) EatToken)*
Err_012         <-  (!(';'  /  '.') EatToken)*
Err_013         <-  (!';' EatToken)*
Err_014         <-  (!('strictfp'  /  'static'  /  'public'  /  'protected'  /  'private'  /  'interface'  /  'import'  /  'final'  /  'enum'  /  'class'  /  'abstract'  /  '@'  /  ';'  /  !.) EatToken)*
Err_015         <-  (!('{'  /  'implements'  /  'extends'  /  '<') EatToken)*
Err_016         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '('  /  !.) EatToken)*
Err_017         <-  (!('{'  /  'void'  /  'short'  /  'long'  /  'int'  /  'implements'  /  'float'  /  'extends'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@') EatToken)*
Err_018         <-  (!('>'  /  ',') EatToken)*
Err_019         <-  (!('{'  /  'implements') EatToken)*
Err_020         <-  (!'{' EatToken)*
Err_021         <-  (!('{'  /  ',') EatToken)*
Err_022         <-  (!('{'  /  ',') EatToken)*
Err_023         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'query'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'instanceof'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  '<'  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')'  /  '('  /  !.) EatToken)*
Err_024         <-  (!('{'  /  'throws'  /  ';') EatToken)*
Err_025         <-  (!(','  /  ')') EatToken)*
Err_026         <-  (!('{'  /  ';') EatToken)*
Err_027         <-  (!('{'  /  ';'  /  ',') EatToken)*
Err_028         <-  (!('{'  /  ';'  /  ',') EatToken)*
Err_029         <-  (!('{'  /  ';'  /  ',') EatToken)*
Err_030         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_031         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_032         <-  (!('short'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@'  /  ')') EatToken)*
Err_033         <-  (!('{'  /  'throws') EatToken)*
Err_034         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_035         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_036         <-  (!';' EatToken)*
Err_037         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_038         <-  (!';' EatToken)*
Err_039         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_040         <-  (!';' EatToken)*
Err_041         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_042         <-  (!';' EatToken)*
Err_043         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_044         <-  (!('{'  /  'implements') EatToken)*
Err_045         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '('  /  !.) EatToken)*
Err_046         <-  (!('}'  /  Identifier  /  '@'  /  ';'  /  ',') EatToken)*
Err_047         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '('  /  !.) EatToken)*
Err_048         <-  (!('{'  /  'extends'  /  '<') EatToken)*
Err_049         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_050         <-  (!'{' EatToken)*
Err_051         <-  (!('}'  /  'void'  /  'strictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_052         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_053         <-  (!'{' EatToken)*
Err_054         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_055         <-  (!('}'  /  'strictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  ';') EatToken)*
Err_056         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_057         <-  (!('}'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'package'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '['  /  '@'  /  '?'  /  '<'  /  ';'  /  '...'  /  ','  /  ')') EatToken)*
Err_058         <-  (!(Identifier  /  ','  /  ')') EatToken)*
Err_059         <-  (!('~'  /  '{'  /  'void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '-'  /  '++'  /  '+'  /  '('  /  '!') EatToken)*
Err_060         <-  (!(Identifier  /  ','  /  ')') EatToken)*
Err_061         <-  (!')' EatToken)*
Err_062         <-  (!('}'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'package'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '['  /  '@'  /  '?'  /  '<'  /  ';'  /  '...'  /  ','  /  ')') EatToken)*
Err_063         <-  (!('{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'short'  /  'return'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'double'  /  'do'  /  'continue'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_064         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_065         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_066         <-  (!('{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'short'  /  'return'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'double'  /  'do'  /  'continue'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_067         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_068         <-  (!'while' EatToken)*
Err_069         <-  (!'(' EatToken)*
Err_070         <-  (!';' EatToken)*
Err_071         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_072         <-  (!'{' EatToken)*
Err_073         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_074         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_075         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_076         <-  (!';' EatToken)*
Err_077         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_078         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_079         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_080         <-  (!(';'  /  ':') EatToken)*
Err_081         <-  (!';' EatToken)*
Err_082         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_083         <-  (!('}'  /  'default'  /  'case') EatToken)*
Err_084         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_085         <-  (!':' EatToken)*
Err_086         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_087         <-  (!':' EatToken)*
Err_088         <-  (!('void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_089         <-  (!('void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '++'  /  ')'  /  '(') EatToken)*
Err_090         <-  (!('{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'short'  /  'return'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'double'  /  'do'  /  'continue'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_091         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_092         <-  (!('short'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@') EatToken)*
Err_093         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_094         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_095         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'finally'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'catch'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_096         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_097         <-  (!('final'  /  Identifier  /  '@') EatToken)*
Err_098         <-  (!')' EatToken)*
Err_099         <-  (!'{' EatToken)*
Err_100         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'finally'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'catch'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_101         <-  (!Identifier EatToken)*
Err_102         <-  (!')' EatToken)*
Err_103         <-  (!('|'  /  Identifier) EatToken)*
Err_104         <-  (!('|'  /  Identifier) EatToken)*
Err_105         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_106         <-  (!('short'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@') EatToken)*
Err_107         <-  (!(';'  /  ')') EatToken)*
Err_108         <-  (!'{' EatToken)*
Err_109         <-  (!(';'  /  ','  /  ')') EatToken)*
Err_110         <-  (!(';'  /  ','  /  ')') EatToken)*
Err_111         <-  (!Identifier EatToken)*
Err_112         <-  (!'=' EatToken)*
Err_113         <-  (!('~'  /  'void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '-'  /  '++'  /  '+'  /  '('  /  '!') EatToken)*
Err_114         <-  (!(';'  /  ','  /  ')') EatToken)*
Err_115         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_116         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_117         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_118         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_119         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_120         <-  (!'(' EatToken)*
Err_121         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_122         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_123         <-  (!'class' EatToken)*
Err_124         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_125         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_126         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_127         <-  (!('}'  /  '{'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_128         <-  (!('<'  /  '.'  /  '(') EatToken)*
Err_129         <-  (!('<'  /  '.'  /  '(') EatToken)*
Err_130         <-  (!('.'  /  '(') EatToken)*
Err_131         <-  (!('{'  /  '['  /  '@') EatToken)*
Err_132         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_133         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_134         <-  (!']' EatToken)*
Err_135         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_136         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_137         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_138         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_139         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_140         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_141         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_142         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_143         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_144         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_145         <-  (!':' EatToken)*
Err_146         <-  (!('~'  /  'void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '-'  /  '++'  /  '+'  /  '('  /  '!') EatToken)*
Err_147         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_148         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_149         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_150         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*	

Property 	unique
compilation     <-  SKIP_unique compilationUnit_unique !.
basicType       <-  ('byte'_unique  /  ('short'_unique  /  ('int'_unique  /  ('long'_unique  /  ('char'_unique  /  ('float'_unique  /  ('double'_unique  /  'boolean'_unique)_unique)_unique)_unique)_unique)_unique)_unique)_unique
primitiveType   <-  annotation* basicType_unique
referenceType   <-  primitiveType dim+_unique  /  classType dim*
classType       <-  annotation* Identifier_unique typeArguments_unique?_unique ('.'_unique annotation_unique*_unique Identifier_unique^Err_001 typeArguments_unique?_unique)*_unique
type            <-  primitiveType_unique  /  classType
arrayType       <-  primitiveType dim+_unique  /  classType dim+
typeVariable    <-  annotation_unique*_unique Identifier_unique^Err_002
dim             <-  annotation* '['_unique ']'_unique^Err_003
typeParameter   <-  typeParameterModifier_unique*_unique Identifier_unique^Err_004 typeBound_unique?_unique
typeParameterModifier <-  annotation_unique
typeBound       <-  'extends'_unique ((classType additionalBound*  /  typeVariable_unique)_unique)^Err_005
additionalBound <-  'and'_unique classType_unique^Err_006
typeArguments   <-  '<' typeArgumentList '>'
typeArgumentList <-  typeArgument (',' typeArgument)*
typeArgument    <-  referenceType  /  wildcard_unique
wildcard        <-  annotation* '?'_unique wildcardBounds_unique?_unique
wildcardBounds  <-  ('extends'_unique referenceType_unique^Err_007  /  'super'_unique referenceType_unique^Err_008)_unique
qualIdent       <-  Identifier ('.' Identifier)*
compilationUnit <-  packageDeclaration_unique?_unique importDeclaration*_unique typeDeclaration_unique*_unique
packageDeclaration <-  packageModifier* 'package'_unique Identifier_unique^Err_009 ('.'_unique Identifier_unique^Err_010)*_unique ';'_unique^Err_011
packageModifier <-  annotation
importDeclaration <-  'import'_unique 'static'_unique?_unique qualIdent_unique^Err_012 ('.'_unique '*'_unique^Err_013)?_unique ';'_unique^Err_014  /  ';'
typeDeclaration <-  (classDeclaration  /  (interfaceDeclaration_unique  /  ';'_unique)_unique)_unique
classDeclaration <-  (normalClassDeclaration_unique  /  enumDeclaration_unique)_unique
normalClassDeclaration <-  classModifier* 'class'_unique Identifier_unique^Err_015 typeParameters_unique?_unique superclass_unique?_unique superinterfaces_unique?_unique classBody_unique^Err_016
classModifier   <-  annotation  /  'public'  /  'protected'  /  'private'  /  'abstract'  /  'static'  /  'final'  /  'strictfp'
typeParameters  <-  '<' typeParameterList_unique '>'_unique^Err_017
typeParameterList <-  typeParameter_unique (','_unique typeParameter_unique^Err_018)*_unique
superclass      <-  'extends'_unique classType_unique^Err_019
superinterfaces <-  'implements'_unique interfaceTypeList_unique^Err_020
interfaceTypeList <-  classType_unique^Err_021 (','_unique classType_unique^Err_022)*_unique
classBody       <-  '{'_unique classBodyDeclaration_unique*_unique '}'_unique^Err_023
classBodyDeclaration <-  (classMemberDeclaration  /  (instanceInitializer_unique  /  (staticInitializer_unique  /  constructorDeclaration_unique)_unique)_unique)_unique
classMemberDeclaration <-  fieldDeclaration  /  methodDeclaration  /  classDeclaration  /  interfaceDeclaration  /  ';'
fieldDeclaration <-  fieldModifier* unannType variableDeclaratorList ';'
variableDeclaratorList <-  variableDeclarator (',' variableDeclarator)*
variableDeclarator <-  variableDeclaratorId ('=' !'=' variableInitializer)?
variableDeclaratorId <-  Identifier dim*
variableInitializer <-  expression  /  arrayInitializer
unannClassType  <-  Identifier typeArguments? ('.' annotation* Identifier_unique typeArguments_unique?_unique)*
unannType       <-  basicType dim*_unique  /  unannClassType dim*
fieldModifier   <-  annotation  /  'public'  /  'protected'  /  'private'  /  'static'  /  'final'  /  ('transient'_unique  /  'volatile'_unique)_unique
methodDeclaration <-  methodModifier* methodHeader methodBody
methodHeader    <-  result methodDeclarator throws?  /  typeParameters annotation* result_unique methodDeclarator_unique^Err_024 throws_unique?_unique
methodDeclarator <-  Identifier '(' formalParameterList? ')' dim*
formalParameterList <-  (receiverParameter  /  formalParameter) (',' formalParameter)*
formalParameter <-  variableModifier* unannType variableDeclaratorId  /  variableModifier* unannType annotation* '...'_unique variableDeclaratorId_unique^Err_025 !','
variableModifier <-  annotation  /  'final'
receiverParameter <-  variableModifier* unannType (Identifier '.')? 'this'
result          <-  unannType  /  'void'
methodModifier  <-  annotation  /  'public'  /  'protected'  /  'private'  /  'abstract'  /  'static'  /  'final'  /  'synchronized'  /  ('native'_unique  /  'stictfp'_unique)_unique
throws          <-  'throws'_unique exceptionTypeList_unique^Err_026
exceptionTypeList <-  exceptionType_unique^Err_027 (','_unique exceptionType_unique^Err_028)*_unique
exceptionType   <-  ((classType  /  typeVariable_unique)_unique)^Err_029
methodBody      <-  block  /  ';'
instanceInitializer <-  block_unique
staticInitializer <-  'static'_unique block_unique^Err_030
constructorDeclaration <-  constructorModifier_unique*_unique constructorDeclarator_unique throws_unique?_unique constructorBody_unique^Err_031
constructorDeclarator <-  typeParameters_unique?_unique Identifier_unique '('_unique^Err_032 formalParameterList_unique?_unique ')'_unique^Err_033
constructorModifier <-  (annotation_unique  /  ('public'_unique  /  ('protected'_unique  /  'private'_unique)_unique)_unique)_unique
constructorBody <-  '{'_unique^Err_034 explicitConstructorInvocation_unique?_unique blockStatements_unique?_unique '}'_unique^Err_035
explicitConstructorInvocation <-  (typeArguments? 'this'_unique arguments_unique^Err_036 ';'_unique^Err_037  /  (typeArguments? 'super'_unique arguments_unique^Err_038 ';'_unique^Err_039  /  (primary '.' typeArguments? 'super'_unique arguments_unique^Err_040 ';'_unique^Err_041  /  qualIdent '.' typeArguments? 'super'_unique arguments_unique^Err_042 ';'_unique^Err_043)_unique)_unique)_unique
enumDeclaration <-  classModifier* 'enum'_unique Identifier_unique^Err_044 superinterfaces_unique?_unique enumBody_unique^Err_045
enumBody        <-  '{'_unique^Err_046 enumConstantList_unique?_unique ','_unique?_unique enumBodyDeclarations_unique?_unique '}'_unique^Err_047
enumConstantList <-  enumConstant_unique (',' enumConstant_unique)*_unique
enumConstant    <-  enumConstantModifier_unique*_unique Identifier_unique arguments_unique?_unique classBody_unique?_unique
enumConstantModifier <-  annotation_unique
enumBodyDeclarations <-  ';'_unique classBodyDeclaration_unique*_unique
interfaceDeclaration <-  (normalInterfaceDeclaration_unique  /  annotationTypeDeclaration_unique)_unique
normalInterfaceDeclaration <-  interfaceModifier* 'interface'_unique Identifier_unique^Err_048 typeParameters_unique?_unique extendsInterfaces_unique?_unique interfaceBody_unique^Err_049
interfaceModifier <-  annotation  /  'public'  /  'protected'  /  'private'  /  'abstract'  /  'static'  /  'strictfp'
extendsInterfaces <-  'extends'_unique interfaceTypeList_unique^Err_050
interfaceBody   <-  '{'_unique^Err_051 interfaceMemberDeclaration_unique*_unique '}'_unique^Err_052
interfaceMemberDeclaration <-  (constantDeclaration  /  (interfaceMethodDeclaration  /  (classDeclaration  /  (interfaceDeclaration_unique  /  ';'_unique)_unique)_unique)_unique)_unique
constantDeclaration <-  constantModifier* unannType variableDeclaratorList ';'
constantModifier <-  annotation  /  'public'  /  'static'  /  'final'
interfaceMethodDeclaration <-  interfaceMethodModifier* methodHeader methodBody
interfaceMethodModifier <-  annotation  /  'public'  /  'abstract'  /  'default'  /  'static'  /  'strictfp'
annotationTypeDeclaration <-  interfaceModifier* '@' 'interface'_unique Identifier_unique^Err_053 annotationTypeBody_unique^Err_054
annotationTypeBody <-  '{'_unique^Err_055 annotationTypeMemberDeclaration_unique*_unique '}'_unique^Err_056
annotationTypeMemberDeclaration <-  (annotationTypeElementDeclaration_unique  /  (constantDeclaration  /  (classDeclaration  /  (interfaceDeclaration_unique  /  ';'_unique)_unique)_unique)_unique)_unique
annotationTypeElementDeclaration <-  annotationTypeElementModifier* unannType Identifier '(' ')' dim* defaultValue? ';'_unique
annotationTypeElementModifier <-  annotation  /  'public'  /  'abstract'
defaultValue    <-  'default' elementValue
annotation      <-  '@' ((normalAnnotation_unique  /  (singleElementAnnotation_unique  /  markerAnnotation_unique)_unique)_unique)
normalAnnotation <-  qualIdent '('_unique elementValuePairList_unique*_unique ')'_unique^Err_057
elementValuePairList <-  elementValuePair_unique (','_unique elementValuePair_unique^Err_058)*_unique
elementValuePair <-  Identifier_unique '='_unique^Err_059 !'=' elementValue_unique^Err_060
elementValue    <-  conditionalExpression  /  elementValueArrayInitializer  /  annotation
elementValueArrayInitializer <-  '{' elementValueList? ','? '}'
elementValueList <-  elementValue (',' elementValue)*
markerAnnotation <-  qualIdent
singleElementAnnotation <-  qualIdent '('_unique elementValue_unique^Err_061 ')'_unique^Err_062
arrayInitializer <-  '{' variableInitializerList? ','? '}'
variableInitializerList <-  variableInitializer (',' variableInitializer)*
block           <-  '{' blockStatements? '}'
blockStatements <-  blockStatement blockStatement*
blockStatement  <-  localVariableDeclarationStatement  /  classDeclaration  /  statement
localVariableDeclarationStatement <-  localVariableDeclaration ';'
localVariableDeclaration <-  variableModifier* unannType variableDeclaratorList
statement       <-  block  /  'if'_unique parExpression_unique^Err_063 statement_unique^Err_064 ('else'_unique statement_unique^Err_065)?_unique  /  basicForStatement_unique  /  enhancedForStatement_unique  /  'while'_unique parExpression_unique^Err_066 statement_unique^Err_067  /  'do'_unique statement_unique^Err_068 'while'_unique^Err_069 parExpression_unique^Err_070 ';'_unique^Err_071  /  tryStatement_unique  /  'switch'_unique parExpression_unique^Err_072 switchBlock_unique^Err_073  /  'synchronized' parExpression_unique block_unique^Err_074  /  'return'_unique expression_unique?_unique ';'_unique^Err_075  /  'throw'_unique expression_unique^Err_076 ';'_unique^Err_077  /  'break'_unique Identifier_unique?_unique ';'_unique^Err_078  /  'continue'_unique Identifier_unique?_unique ';'_unique^Err_079  /  'assert'_unique expression_unique^Err_080 (':'_unique expression_unique^Err_081)?_unique ';'_unique^Err_082  /  ';'  /  statementExpression ';'  /  Identifier ':' statement
statementExpression <-  assignment  /  ('++'  /  '--') (primary  /  qualIdent)  /  (primary  /  qualIdent) (('++'  /  '--')_unique)  /  primary
switchBlock     <-  '{'_unique^Err_083 switchBlockStatementGroup*_unique switchLabel_unique*_unique '}'_unique^Err_084
switchBlockStatementGroup <-  switchLabels blockStatements
switchLabels    <-  switchLabel switchLabel*
switchLabel     <-  ('case'_unique ((constantExpression  /  enumConstantName_unique)_unique)^Err_085 ':'_unique^Err_086  /  'default' ':'_unique)_unique
enumConstantName <-  Identifier_unique^Err_087
basicForStatement <-  'for' '('^Err_088 forInit? ';'_unique expression_unique?_unique ';'_unique^Err_089 forUpdate_unique?_unique ')'_unique^Err_090 statement_unique^Err_091
forInit         <-  localVariableDeclaration  /  statementExpressionList
forUpdate       <-  statementExpressionList_unique
statementExpressionList <-  statementExpression (',' statementExpression)*
enhancedForStatement <-  'for' '('^Err_092 variableModifier* unannType variableDeclaratorId ':' expression ')'_unique statement_unique^Err_093
tryStatement    <-  'try'_unique ((block_unique ((catchClause_unique* finally_unique  /  catchClause_unique+_unique)_unique)^Err_094  /  resourceSpecification_unique block_unique^Err_095 catchClause_unique*_unique finally_unique?_unique)_unique)^Err_096
catchClause     <-  'catch'_unique '('_unique^Err_097 catchFormalParameter_unique^Err_098 ')'_unique^Err_099 block_unique^Err_100
catchFormalParameter <-  variableModifier_unique*_unique catchType_unique^Err_101 variableDeclaratorId_unique^Err_102
catchType       <-  unannClassType_unique^Err_103 ('|'_unique ![=|] classType_unique^Err_104)*_unique
finally         <-  'finally'_unique block_unique^Err_105
resourceSpecification <-  '('_unique^Err_106 resourceList_unique^Err_107 ';'_unique?_unique ')'_unique^Err_108
resourceList    <-  resource_unique^Err_109 (','_unique resource_unique^Err_110)*_unique
resource        <-  variableModifier_unique*_unique unannType_unique^Err_111 variableDeclaratorId_unique^Err_112 '='_unique^Err_113 !'=' expression_unique^Err_114
expression      <-  lambdaExpression  /  assignmentExpression
primary         <-  primaryBase primaryRest*
primaryBase     <-  'this'  /  Literal_unique  /  parExpression  /  'super' (('.' typeArguments? Identifier_unique arguments_unique^Err_115  /  '.' Identifier  /  '::' typeArguments? Identifier_unique)_unique)  /  'new'_unique ((classCreator  /  arrayCreator_unique)_unique)^Err_116  /  qualIdent ('[' expression ']'_unique  /  arguments  /  '.' ('this'  /  'new' classCreator^Err_117  /  typeArguments Identifier_unique arguments_unique^Err_118  /  'super' '.' typeArguments? Identifier_unique arguments_unique^Err_119  /  'super' '.' Identifier  /  'super' '::'_unique typeArguments_unique?_unique Identifier_unique^Err_120 arguments_unique^Err_121)  /  ('[' ']')* '.' 'class'  /  '::' typeArguments? Identifier_unique)  /  'void' '.'_unique 'class'_unique^Err_122  /  basicType ('[' ']')*_unique '.'_unique^Err_123 'class'_unique^Err_124  /  referenceType '::' typeArguments? 'new'_unique  /  arrayType '::' 'new'
primaryRest     <-  '.' (typeArguments? Identifier_unique arguments_unique^Err_125  /  Identifier  /  'new' classCreator^Err_126)  /  ('[' expression ']'_unique  /  '::' typeArguments? Identifier_unique)_unique
parExpression   <-  '(' expression ')'
classCreator    <-  typeArguments_unique? annotation*_unique classTypeWithDiamond_unique arguments_unique^Err_127 classBody_unique?_unique
classTypeWithDiamond <-  annotation_unique*_unique Identifier_unique^Err_128 typeArgumentsOrDiamond_unique?_unique ('.'_unique annotation_unique*_unique Identifier_unique^Err_129 typeArgumentsOrDiamond_unique?_unique)*_unique
typeArgumentsOrDiamond <-  (typeArguments  /  '<'_unique '>'_unique^Err_130 !'.')_unique
arrayCreator    <-  ((type dimExpr_unique+_unique dim*_unique  /  type_unique dim_unique+_unique^Err_131 arrayInitializer_unique^Err_132)_unique)^Err_133
dimExpr         <-  annotation* '['_unique expression_unique^Err_134 ']'_unique^Err_135
arguments       <-  '(' argumentList? ')'
argumentList    <-  expression (',' expression)*
unaryExpression <-  ('++'  /  '--') (primary  /  qualIdent)  /  '+'_unique ![=+] unaryExpression_unique^Err_136  /  '-'_unique ![-=>] unaryExpression_unique^Err_137  /  unaryExpressionNotPlusMinus
unaryExpressionNotPlusMinus <-  '~'_unique unaryExpression_unique^Err_138  /  '!'_unique ![=&] unaryExpression_unique^Err_139  /  castExpression_unique  /  (primary  /  qualIdent) ('++'  /  '--')?
castExpression  <-  ('(' primitiveType ')'_unique unaryExpression_unique^Err_140  /  ('(' referenceType additionalBound* ')'_unique lambdaExpression_unique^Err_141  /  '(' referenceType additionalBound* ')'_unique unaryExpressionNotPlusMinus_unique^Err_142)_unique)_unique
infixExpression <-  unaryExpression ((InfixOperator_unique unaryExpression_unique^Err_143  /  'instanceof'_unique referenceType_unique^Err_144)_unique)*
InfixOperator   <-  '||'  /  '&&'  /  '|' ![=|]  /  '^' ![=]  /  '&' ![=&]  /  '=='  /  '!='  /  '<' ![=<]  /  '>' ![=>]  /  '<='  /  '>='  /  '<<' ![=]  /  '>>' ![=>]  /  '>>>' ![=]  /  '+' ![=+]  /  '-' ![-=>]  /  '*' ![=]  /  '/' ![=]  /  '%' ![=]
conditionalExpression <-  infixExpression ('query'_unique expression_unique^Err_145 ':'_unique^Err_146 expression_unique^Err_147)*
assignmentExpression <-  assignment  /  conditionalExpression
assignment      <-  leftHandSide AssignmentOperator_unique expression_unique^Err_148
leftHandSide    <-  primary  /  qualIdent
AssignmentOperator <-  '=' ![=]  /  '*='  /  '/='  /  '%='  /  '+='  /  '-='  /  '<<='  /  '>>='  /  '>>>='  /  '&='  /  '^='  /  '|='
lambdaExpression <-  lambdaParameters '->'_unique lambdaBody_unique^Err_149
lambdaParameters <-  Identifier  /  '(' formalParameterList? ')'  /  '(' inferredFormalParameterList ')'
inferredFormalParameterList <-  Identifier (',' Identifier)*
lambdaBody      <-  ((expression_unique  /  block_unique)_unique)^Err_150
constantExpression <-  expression
Identifier      <-  !Keywords [a-zA-Z_] [a-zA-Z_$0-9]*
Keywords        <-  ('abstract'  /  'assert'  /  'boolean'  /  'break'  /  'byte'  /  'case'  /  'catch'  /  'char'  /  'class'  /  'const'  /  'continue'  /  'default'  /  'double'  /  'do'  /  'else'  /  'enum'  /  'extends'  /  'false'  /  'finally'  /  'final'  /  'float'  /  'for'  /  'goto'  /  'if'  /  'implements'  /  'import'  /  'interface'  /  'int'  /  'instanceof'  /  'long'  /  'native'  /  'new'  /  'null'  /  'package'  /  'private'  /  'protected'  /  'public'  /  'return'  /  'short'  /  'static'  /  'strictfp'  /  'super'  /  'switch'  /  'synchronized'  /  'this'  /  'throws'  /  'throw'  /  'transient'  /  'true'  /  'try'  /  'void'  /  'volatile'  /  'while') ![a-zA-Z_$0-9]
Literal         <-  FloatLiteral  /  IntegerLiteral  /  BooleanLiteral  /  CharLiteral  /  StringLiteral  /  NullLiteral
IntegerLiteral  <-  (HexNumeral  /  BinaryNumeral  /  OctalNumeral  /  DecimalNumeral) [lL]?
DecimalNumeral  <-  '0'  /  [1-9] ([_]* [0-9])*
HexNumeral      <-  ('0x'  /  '0X') HexDigits
OctalNumeral    <-  '0' ([_]* [0-7])+
BinaryNumeral   <-  ('0b'  /  '0B') [01] ([_]* [01])*
FloatLiteral    <-  HexaDecimalFloatingPointLiteral  /  DecimalFloatingPointLiteral
DecimalFloatingPointLiteral <-  Digits '.' Digits? Exponent? [fFdD]?  /  '.' Digits Exponent? [fFdD]?  /  Digits Exponent [fFdD]?  /  Digits Exponent? [fFdD]
Exponent        <-  [eE] [-+]? Digits
HexaDecimalFloatingPointLiteral <-  HexSignificand BinaryExponent [fFdD]?
HexSignificand  <-  ('0x'  /  '0X') HexDigits? '.' HexDigits  /  HexNumeral '.'?
HexDigits       <-  HexDigit ([_]* HexDigit)*
HexDigit        <-  [a-f]  /  [A-F]  /  [0-9]
BinaryExponent  <-  [pP] [-+]? Digits
Digits          <-  [0-9] ([_]* [0-9])*
BooleanLiteral  <-  'true'  /  'false'
CharLiteral     <-  "'" (%nl  /  !"'" .) "'"
StringLiteral   <-  '"' (%nl  /  !'"' .)* '"'
NullLiteral     <-  'null'
COMMENT         <-  '//' (!%nl .)*  /  '/*' (!'*/' .)* '*/'
SPACE           <-  [ 	
]  /  COMMENT
SKIP            <-  ([ 	
]  /  COMMENT)*
Token           <-  '~'  /  '}'  /  '{'  /  'stictfp'  /  'query'  /  'and'  /  StringLiteral  /  OctalNumeral  /  NullLiteral  /  Literal  /  Keywords  /  IntegerLiteral  /  InfixOperator  /  Identifier  /  HexaDecimalFloatingPointLiteral  /  HexSignificand  /  HexNumeral  /  HexDigits  /  HexDigit  /  FloatLiteral  /  Exponent  /  Digits  /  DecimalNumeral  /  DecimalFloatingPointLiteral  /  CharLiteral  /  COMMENT  /  BooleanLiteral  /  BinaryNumeral  /  BinaryExponent  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  '?'  /  ';'  /  '::'  /  ':'  /  '...'  /  '->'  /  '--'  /  ','  /  '++'  /  ')'  /  '('  /  '!'
EatToken        <-  (Token  /  (!SPACE .)+) SKIP
Err_001         <-  (!('}'  /  '|'  /  '{'  /  'query'  /  'instanceof'  /  'implements'  /  'and'  /  InfixOperator  /  Identifier  /  ']'  /  '['  /  '@'  /  '>'  /  '<'  /  ';'  /  '::'  /  ':'  /  '.'  /  ','  /  ')') EatToken)*
Err_002         <-  (!('{'  /  '>'  /  ';'  /  ',') EatToken)*
Err_003         <-  (!('}'  /  '{'  /  'throws'  /  'this'  /  'query'  /  'instanceof'  /  'default'  /  'and'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  '>'  /  '='  /  ';'  /  '::'  /  ':'  /  '...'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_004         <-  (!('extends'  /  '>'  /  ',') EatToken)*
Err_005         <-  (!('>'  /  ',') EatToken)*
Err_006         <-  (!('and'  /  '>'  /  ','  /  ')') EatToken)*
Err_007         <-  (!('>'  /  ',') EatToken)*
Err_008         <-  (!('>'  /  ',') EatToken)*
Err_009         <-  (!(';'  /  '.') EatToken)*
Err_010         <-  (!(';'  /  '.') EatToken)*
Err_011         <-  (!('strictfp'  /  'static'  /  'public'  /  'protected'  /  'private'  /  'interface'  /  'import'  /  'final'  /  'enum'  /  'class'  /  'abstract'  /  '@'  /  ';'  /  !.) EatToken)*
Err_012         <-  (!(';'  /  '.') EatToken)*
Err_013         <-  (!';' EatToken)*
Err_014         <-  (!('strictfp'  /  'static'  /  'public'  /  'protected'  /  'private'  /  'interface'  /  'import'  /  'final'  /  'enum'  /  'class'  /  'abstract'  /  '@'  /  ';'  /  !.) EatToken)*
Err_015         <-  (!('{'  /  'implements'  /  'extends'  /  '<') EatToken)*
Err_016         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '('  /  !.) EatToken)*
Err_017         <-  (!('{'  /  'void'  /  'short'  /  'long'  /  'int'  /  'implements'  /  'float'  /  'extends'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@') EatToken)*
Err_018         <-  (!('>'  /  ',') EatToken)*
Err_019         <-  (!('{'  /  'implements') EatToken)*
Err_020         <-  (!'{' EatToken)*
Err_021         <-  (!('{'  /  ',') EatToken)*
Err_022         <-  (!('{'  /  ',') EatToken)*
Err_023         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'query'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'instanceof'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  '<'  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')'  /  '('  /  !.) EatToken)*
Err_024         <-  (!('{'  /  'throws'  /  ';') EatToken)*
Err_025         <-  (!(','  /  ')') EatToken)*
Err_026         <-  (!('{'  /  ';') EatToken)*
Err_027         <-  (!('{'  /  ';'  /  ',') EatToken)*
Err_028         <-  (!('{'  /  ';'  /  ',') EatToken)*
Err_029         <-  (!('{'  /  ';'  /  ',') EatToken)*
Err_030         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_031         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_032         <-  (!('short'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@'  /  ')') EatToken)*
Err_033         <-  (!('{'  /  'throws') EatToken)*
Err_034         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_035         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_036         <-  (!';' EatToken)*
Err_037         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_038         <-  (!';' EatToken)*
Err_039         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_040         <-  (!';' EatToken)*
Err_041         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_042         <-  (!';' EatToken)*
Err_043         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'continue'  /  'class'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_044         <-  (!('{'  /  'implements') EatToken)*
Err_045         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '('  /  !.) EatToken)*
Err_046         <-  (!('}'  /  Identifier  /  '@'  /  ';'  /  ',') EatToken)*
Err_047         <-  (!('}'  /  '{'  /  'while'  /  'volatile'  /  'void'  /  'try'  /  'transient'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  '<'  /  ';'  /  '--'  /  '++'  /  '('  /  !.) EatToken)*
Err_048         <-  (!('{'  /  'extends'  /  '<') EatToken)*
Err_049         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_050         <-  (!'{' EatToken)*
Err_051         <-  (!('}'  /  'void'  /  'strictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';') EatToken)*
Err_052         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_053         <-  (!'{' EatToken)*
Err_054         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_055         <-  (!('}'  /  'strictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  ';') EatToken)*
Err_056         <-  (!('}'  /  '{'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '@'  /  '<'  /  ';'  /  !.) EatToken)*
Err_057         <-  (!('}'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'package'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '['  /  '@'  /  '?'  /  '<'  /  ';'  /  '...'  /  ','  /  ')') EatToken)*
Err_058         <-  (!(Identifier  /  ','  /  ')') EatToken)*
Err_059         <-  (!('~'  /  '{'  /  'void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '-'  /  '++'  /  '+'  /  '('  /  '!') EatToken)*
Err_060         <-  (!(Identifier  /  ','  /  ')') EatToken)*
Err_061         <-  (!')' EatToken)*
Err_062         <-  (!('}'  /  'volatile'  /  'void'  /  'transient'  /  'synchronized'  /  'strictfp'  /  'stictfp'  /  'static'  /  'short'  /  'public'  /  'protected'  /  'private'  /  'package'  /  'native'  /  'long'  /  'interface'  /  'int'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'default'  /  'class'  /  'char'  /  'byte'  /  'boolean'  /  'abstract'  /  Identifier  /  '['  /  '@'  /  '?'  /  '<'  /  ';'  /  '...'  /  ','  /  ')') EatToken)*
Err_063         <-  (!('{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'short'  /  'return'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'double'  /  'do'  /  'continue'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_064         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_065         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_066         <-  (!('{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'short'  /  'return'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'double'  /  'do'  /  'continue'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_067         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_068         <-  (!'while' EatToken)*
Err_069         <-  (!'(' EatToken)*
Err_070         <-  (!';' EatToken)*
Err_071         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_072         <-  (!'{' EatToken)*
Err_073         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_074         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_075         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_076         <-  (!';' EatToken)*
Err_077         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_078         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_079         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_080         <-  (!(';'  /  ':') EatToken)*
Err_081         <-  (!';' EatToken)*
Err_082         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_083         <-  (!('}'  /  'default'  /  'case') EatToken)*
Err_084         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_085         <-  (!':' EatToken)*
Err_086         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_087         <-  (!':' EatToken)*
Err_088         <-  (!('void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_089         <-  (!('void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '++'  /  ')'  /  '(') EatToken)*
Err_090         <-  (!('{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'short'  /  'return'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'double'  /  'do'  /  'continue'  /  'char'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_091         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_092         <-  (!('short'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@') EatToken)*
Err_093         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_094         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_095         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'finally'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'catch'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_096         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_097         <-  (!('final'  /  Identifier  /  '@') EatToken)*
Err_098         <-  (!')' EatToken)*
Err_099         <-  (!'{' EatToken)*
Err_100         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'finally'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'catch'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_101         <-  (!Identifier EatToken)*
Err_102         <-  (!')' EatToken)*
Err_103         <-  (!('|'  /  Identifier) EatToken)*
Err_104         <-  (!('|'  /  Identifier) EatToken)*
Err_105         <-  (!('}'  /  '{'  /  'while'  /  'void'  /  'try'  /  'throw'  /  'this'  /  'synchronized'  /  'switch'  /  'super'  /  'strictfp'  /  'static'  /  'short'  /  'return'  /  'public'  /  'protected'  /  'private'  /  'new'  /  'long'  /  'int'  /  'if'  /  'for'  /  'float'  /  'final'  /  'enum'  /  'else'  /  'double'  /  'do'  /  'default'  /  'continue'  /  'class'  /  'char'  /  'case'  /  'byte'  /  'break'  /  'boolean'  /  'assert'  /  'abstract'  /  Literal  /  Identifier  /  '@'  /  ';'  /  '--'  /  '++'  /  '(') EatToken)*
Err_106         <-  (!('short'  /  'long'  /  'int'  /  'float'  /  'final'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Identifier  /  '@') EatToken)*
Err_107         <-  (!(';'  /  ')') EatToken)*
Err_108         <-  (!'{' EatToken)*
Err_109         <-  (!(';'  /  ','  /  ')') EatToken)*
Err_110         <-  (!(';'  /  ','  /  ')') EatToken)*
Err_111         <-  (!Identifier EatToken)*
Err_112         <-  (!'=' EatToken)*
Err_113         <-  (!('~'  /  'void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '-'  /  '++'  /  '+'  /  '('  /  '!') EatToken)*
Err_114         <-  (!(';'  /  ','  /  ')') EatToken)*
Err_115         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_116         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_117         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_118         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_119         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_120         <-  (!'(' EatToken)*
Err_121         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_122         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_123         <-  (!'class' EatToken)*
Err_124         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_125         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_126         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_127         <-  (!('}'  /  '{'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_128         <-  (!('<'  /  '.'  /  '(') EatToken)*
Err_129         <-  (!('<'  /  '.'  /  '(') EatToken)*
Err_130         <-  (!('.'  /  '(') EatToken)*
Err_131         <-  (!('{'  /  '['  /  '@') EatToken)*
Err_132         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_133         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_134         <-  (!']' EatToken)*
Err_135         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  AssignmentOperator  /  ']'  /  '['  /  '@'  /  ';'  /  '::'  /  ':'  /  '.'  /  '--'  /  ','  /  '++'  /  ')') EatToken)*
Err_136         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_137         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_138         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_139         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_140         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_141         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_142         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_143         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_144         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_145         <-  (!':' EatToken)*
Err_146         <-  (!('~'  /  'void'  /  'this'  /  'super'  /  'short'  /  'new'  /  'long'  /  'int'  /  'float'  /  'double'  /  'char'  /  'byte'  /  'boolean'  /  Literal  /  Identifier  /  '@'  /  '--'  /  '-'  /  '++'  /  '+'  /  '('  /  '!') EatToken)*
Err_147         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_148         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_149         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*
Err_150         <-  (!('}'  /  'query'  /  'instanceof'  /  InfixOperator  /  Identifier  /  ']'  /  ';'  /  ':'  /  ','  /  ')') EatToken)*	

End UPath

Yes: 	AllTests.java
Yes: 	Aluno.java
Yes: 	AnInterface.java
Yes: 	Anotacao.java
Yes: 	ArgumentsErr4.java
Yes: 	ArrayAverage.java
Yes: 	BlockStatementsErr.java
Yes: 	Car.java
Yes: 	Currency.java
Yes: 	DAOAtividade.java
Yes: 	Disciplina.java
Yes: 	ElementValueErr3.java
Yes: 	Empty.java
Yes: 	EqAvaliableErr2.java
Yes: 	Expression.java
Yes: 	HelloWorld.java
Yes: 	IssueController.java
Yes: 	JsonField.java
Yes: 	JsonSerializer.java
Yes: 	LambdaExpressions.java
Yes: 	MultithreadingDemo.java
Yes: 	MyTestRunner.java
Yes: 	MyTests.java
Yes: 	Pessoa.java
Yes: 	Pilha.java
Yes: 	Singleton.java
Yes: 	SortMain.java
Yes: 	Tester.java
Yes: 	UnaryExpressionNotPlusMinusErr.java
Yes: 	Veiculo.java
No: 	AfterBlockErr.java
r = nil lab = fail line: 6 col: 7
No: 	AfterIteratorSymbolErr.java
r = nil lab = fail line: 3 col: 6
No: 	AfterNewErr.java
r = nil lab = fail line: 3 col: 26
No: 	AfterSuperErr.java
r = nil lab = fail line: 3 col: 18
No: 	AfterTryErr.java
r = nil lab = fail line: 3 col: 7
No: 	AnnotationTypeBodyErr.java
r = nil lab = fail line: 2 col: 2
No: 	ArgumentsErr1.java
r = nil lab = fail line: 3 col: 13
No: 	ArgumentsErr2.java
r = nil lab = fail line: 3 col: 10
No: 	ArgumentsErr3.java
r = nil lab = fail line: 3 col: 16
No: 	ArgumentsErr5.java
r = nil lab = fail line: 3 col: 20
No: 	ArrayInitializerErr.java
r = nil lab = fail line: 3 col: 30
No: 	AsteriskErr.java
r = nil lab = fail line: 1 col: 13
No: 	BlockErr1.java
r = nil lab = fail line: 2 col: 9
No: 	BlockErr2.java
r = nil lab = fail line: 4 col: 4
No: 	BlockErr3.java
r = nil lab = fail line: 4 col: 4
No: 	BlockErr4.java
r = nil lab = fail line: 6 col: 23
No: 	BlockErr5.java
r = nil lab = fail line: 7 col: 11
No: 	CLASSErr1.java
r = nil lab = fail line: 3 col: 18
No: 	CLASSErr2.java
r = nil lab = fail line: 3 col: 19
No: 	CaseExpressionErr.java
r = nil lab = fail line: 4 col: 10
No: 	CatchFormalParameterErr.java
r = nil lab = fail line: 6 col: 10
No: 	ClassBodyErr.java
r = nil lab = fail line: 2 col: 2
No: 	ClassCreatorErr1.java
r = nil lab = fail line: 3 col: 19
No: 	ClassCreatorErr2.java
r = nil lab = fail line: 3 col: 24
No: 	ClassTypeErr1.java
r = nil lab = fail line: 1 col: 45
No: 	ClassTypeErr2.java
r = nil lab = fail line: 1 col: 41
No: 	ClassTypeErr3.java
r = nil lab = fail line: 1 col: 44
No: 	ClassTypeErr4.java
r = nil lab = fail line: 6 col: 22
No: 	ColonErr1.java
r = nil lab = fail line: 3 col: 6
No: 	ColonErr2.java
r = nil lab = fail line: 5 col: 5
No: 	ColonErr3.java
r = nil lab = fail line: 8 col: 18
No: 	ColonErr4.java
r = nil lab = fail line: 3 col: 14
No: 	ColonErr5.java
r = nil lab = fail line: 3 col: 24
No: 	CommaAvaliableErr.java
r = nil lab = fail line: 2 col: 32
No: 	ConstructorBodyErr.java
r = nil lab = fail line: 2 col: 23
No: 	CurRBrackErr1.java
r = nil lab = fail line: 2 col: 14
No: 	CurRBrackErr2.java
r = nil lab = fail line: 2 col: 19
No: 	CurRBrackErr3.java
r = nil lab = fail line: 4 col: 1
No: 	CurRBrackErr4.java
r = nil lab = fail line: 4 col: 1
No: 	CurRBrackErr5.java
r = nil lab = fail line: 2 col: 16
No: 	CurRBrackErr6.java
r = nil lab = fail line: 1 col: 23
No: 	CurRBrackErr7.java
r = nil lab = fail line: 3 col: 17
No: 	CurRBrackErr8.java
r = nil lab = fail line: 5 col: 8
No: 	CurRBrackErr9.java
r = nil lab = fail line: 9 col: 3
No: 	DotAvaliableErr.java
r = nil lab = fail line: 3 col: 34
No: 	DotErr1.java
r = nil lab = fail line: 3 col: 13
No: 	ElementValueErr1.java
r = nil lab = fail line: 2 col: 22
No: 	ElementValueErr2.java
r = nil lab = fail line: 1 col: 21
No: 	ElementValueErr4.java
r = nil lab = fail line: 1 col: 14
No: 	ElementValuePairErr.java
r = nil lab = fail line: 1 col: 19
No: 	EndErr.java
r = nil lab = fail line: 5 col: 1
No: 	EnumBodyErr.java
r = nil lab = fail line: 3 col: 1
No: 	EqAvaliableErr1.java
r = nil lab = fail line: 3 col: 13
No: 	EqAvaliableErr3.java
r = nil lab = fail line: 3 col: 15
No: 	EqVerticalBarAvaliableErr.java
r = nil lab = fail line: 6 col: 21
No: 	EqualAmpersandErr.java
r = nil lab = fail line: 3 col: 14
No: 	EqualPlusErr.java
r = nil lab = fail line: 3 col: 14
No: 	ExceptionTypeErr.java
r = nil lab = fail line: 2 col: 46
No: 	ExceptionTypeListErr.java
r = nil lab = fail line: 2 col: 43
No: 	ExpressionErr1.java
r = nil lab = fail line: 3 col: 10
No: 	ExpressionErr10.java
r = nil lab = fail line: 3 col: 11
No: 	ExpressionErr2.java
r = nil lab = fail line: 3 col: 11
No: 	ExpressionErr3.java
r = nil lab = fail line: 3 col: 14
No: 	ExpressionErr4.java
r = nil lab = fail line: 3 col: 17
No: 	ExpressionErr5.java
r = nil lab = fail line: 3 col: 17
No: 	ExpressionErr6.java
r = nil lab = fail line: 3 col: 20
No: 	ExpressionErr7.java
r = nil lab = fail line: 3 col: 35
No: 	ExpressionErr8.java
r = nil lab = fail line: 3 col: 24
No: 	ExpressionErr9.java
r = nil lab = fail line: 3 col: 27
No: 	FormalParameterErr.java
r = nil lab = fail line: 2 col: 30
No: 	GeqErr.java
r = nil lab = fail line: 1 col: 23
No: 	GreaterErr1.java
r = nil lab = fail line: 3 col: 33
No: 	IdErr1.java
r = nil lab = fail line: 1 col: 9
No: 	IdErr10.java
r = nil lab = fail line: 3 col: 14
No: 	IdErr11.java
r = nil lab = fail line: 3 col: 17
No: 	IdErr12.java
r = nil lab = fail line: 3 col: 18
No: 	IdErr13.java
r = nil lab = fail line: 3 col: 12
No: 	IdErr14.java
r = nil lab = fail line: 3 col: 21
No: 	IdErr15.java
r = nil lab = fail line: 3 col: 33
No: 	IdErr16.java
r = nil lab = fail line: 3 col: 14
No: 	IdErr2.java
r = nil lab = fail line: 1 col: 14
No: 	IdErr3.java
r = nil lab = fail line: 1 col: 14
No: 	IdErr4.java
r = nil lab = fail line: 1 col: 13
No: 	IdErr5.java
r = nil lab = fail line: 1 col: 18
No: 	IdErr6.java
r = nil lab = fail line: 1 col: 19
No: 	IdErr7.java
r = nil lab = fail line: 2 col: 6
No: 	IdErr8.java
r = nil lab = fail line: 3 col: 19
No: 	IdErr9.java
r = nil lab = fail line: 3 col: 20
No: 	InterfaceBodyErr.java
r = nil lab = fail line: 3 col: 1
No: 	InterfaceTypeListErr1.java
r = nil lab = fail line: 1 col: 49
No: 	InterfaceTypeListErr2.java
r = nil lab = fail line: 1 col: 50
No: 	InterfaceWordErr.java
r = nil lab = fail line: 1 col: 12
No: 	LParErr1.java
r = nil lab = fail line: 2 col: 25
No: 	LParErr2.java
r = nil lab = fail line: 2 col: 10
No: 	LParErr3.java
r = nil lab = fail line: 2 col: 11
No: 	LParErr4.java
r = nil lab = fail line: 3 col: 7
No: 	LParErr5.java
r = nil lab = fail line: 6 col: 9
No: 	LambdaBodyErr.java
r = nil lab = fail line: 3 col: 17
No: 	MethodBodyErr1.java
r = nil lab = fail line: 4 col: 2
No: 	MethodBodyErr2.java
r = nil lab = fail line: 2 col: 20
No: 	MethodDeclaratorErr.java
r = nil lab = fail line: 2 col: 18
No: 	MinusEqualGreaterErr.java
r = nil lab = fail line: 3 col: 14
No: 	NEWErr1.java
r = nil lab = fail line: 3 col: 18
No: 	ParExpressionErr1.java
r = nil lab = fail line: 3 col: 6
No: 	ParExpressionErr2.java
r = nil lab = fail line: 3 col: 9
No: 	ParExpressionErr3.java
r = nil lab = fail line: 5 col: 9
No: 	ParExpressionErr4.java
r = nil lab = fail line: 3 col: 10
No: 	ParExpressionErr5.java
r = nil lab = fail line: 3 col: 16
No: 	PrimaryQualIdentErr.java
r = nil lab = fail line: 3 col: 16
No: 	QualIdentErr1.java
r = nil lab = fail line: 1 col: 8
No: 	RBrackErr1.java
r = nil lab = fail line: 3 col: 17
No: 	RBrackErr2.java
r = nil lab = fail line: 3 col: 12
No: 	RBrackErr3.java
r = nil lab = fail line: 3 col: 13
No: 	RBrackErr4.java
r = nil lab = fail line: 3 col: 25
No: 	RBrackErr5.java
r = nil lab = fail line: 3 col: 31
No: 	RParErr1.java
r = nil lab = fail line: 2 col: 29
No: 	RParErr10.java
r = nil lab = fail line: 3 col: 33
No: 	RParErr11.java
r = nil lab = fail line: 3 col: 19
No: 	RParErr2.java
r = nil lab = fail line: 2 col: 12
No: 	RParErr3.java
r = nil lab = fail line: 2 col: 12
No: 	RParErr4.java
r = nil lab = fail line: 2 col: 1
No: 	RParErr5.java
r = nil lab = fail line: 3 col: 31
No: 	RParErr6.java
r = nil lab = fail line: 3 col: 18
No: 	RParErr7.java
r = nil lab = fail line: 6 col: 22
No: 	RParErr8.java
r = nil lab = fail line: 3 col: 18
No: 	RParErr9.java
r = nil lab = fail line: 3 col: 19
No: 	ReferenceTypeErr1.java
r = nil lab = fail line: 1 col: 53
No: 	ReferenceTypeErr2.java
r = nil lab = fail line: 1 col: 51
No: 	ReferenceTypeErr3.java
r = nil lab = fail line: 3 col: 22
No: 	ResourceErr.java
r = nil lab = fail line: 3 col: 19
No: 	ResourceListErr.java
r = nil lab = fail line: 3 col: 8
No: 	ResultErr.java
r = nil lab = fail line: 2 col: 13
No: 	SUPERErr1.java
r = nil lab = fail line: 3 col: 13
No: 	SUPERErr2.java
r = nil lab = fail line: 3 col: 16
No: 	SemiErr1.java
r = nil lab = fail line: 1 col: 15
No: 	SemiErr10.java
r = nil lab = fail line: 3 col: 9
No: 	SemiErr11.java
r = nil lab = fail line: 4 col: 2
No: 	SemiErr12.java
r = nil lab = fail line: 4 col: 2
No: 	SemiErr13.java
r = nil lab = fail line: 4 col: 2
No: 	SemiErr14.java
r = nil lab = fail line: 4 col: 2
No: 	SemiErr15.java
r = nil lab = fail line: 4 col: 3
No: 	SemiErr16.java
r = nil lab = fail line: 3 col: 27
No: 	SemiErr2.java
r = nil lab = fail line: 1 col: 14
No: 	SemiErr3.java
r = nil lab = fail line: 4 col: 3
No: 	SemiErr4.java
r = nil lab = fail line: 4 col: 3
No: 	SemiErr5.java
r = nil lab = fail line: 4 col: 5
No: 	SemiErr6.java
r = nil lab = fail line: 4 col: 2
No: 	SemiErr7.java
r = nil lab = fail line: 3 col: 1
No: 	SemiErr8.java
r = nil lab = fail line: 4 col: 2
No: 	SemiErr9.java
r = nil lab = fail line: 6 col: 2
No: 	StatementErr1.java
r = nil lab = fail line: 4 col: 5
No: 	StatementErr2.java
r = nil lab = fail line: 6 col: 5
No: 	StatementErr3.java
r = nil lab = fail line: 4 col: 5
No: 	StatementErr4.java
r = nil lab = fail line: 5 col: 8
No: 	StatementErr5.java
r = nil lab = fail line: 3 col: 8
No: 	StatementErr6.java
r = nil lab = fail line: 4 col: 13
No: 	StatementErr7.java
r = nil lab = fail line: 4 col: 4
No: 	StatementExpressionErr.java
r = nil lab = fail line: 3 col: 15
No: 	SwitchBlockErr.java
r = nil lab = fail line: 4 col: 4
No: 	TypeArgumentErr.java
r = nil lab = fail line: 1 col: 44
No: 	TypeParameterErr.java
r = nil lab = fail line: 1 col: 33
No: 	TypeParameterListErr.java
r = nil lab = fail line: 1 col: 36
No: 	UnaryExpressionErr1.java
r = nil lab = fail line: 3 col: 15
No: 	UnaryExpressionErr2.java
r = nil lab = fail line: 3 col: 15
No: 	UnaryExpressionErr3.java
r = nil lab = fail line: 3 col: 15
No: 	UnaryExpressionErr4.java
r = nil lab = fail line: 3 col: 15
No: 	UnaryExpressionErr5.java
r = nil lab = fail line: 3 col: 20
No: 	UnaryExpressionErr6.java
r = nil lab = fail line: 3 col: 18
No: 	VariableDeclaratorErr.java
r = nil lab = fail line: 2 col: 17
No: 	VariableDeclaratorIdErr1.java
r = nil lab = fail line: 2 col: 31
No: 	VariableDeclaratorIdErr2.java
r = nil lab = fail line: 6 col: 20
No: 	VariableDeclaratorIdErr3.java
r = nil lab = fail line: 3 col: 12
No: 	VariableDeclaratorListErr.java
r = nil lab = fail line: 2 col: 12
No: 	VariableInitializerErr1.java
r = nil lab = fail line: 2 col: 19
No: 	WHILEErr.java
r = nil lab = fail line: 5 col: 3
