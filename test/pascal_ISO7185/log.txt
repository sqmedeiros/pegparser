Yes: 	HelloWorld.pas
Yes: 	PlayingWithDice.pas
Yes: 	Teste.pas
Yes: 	aprovado.pas
Yes: 	bubble.pas
Yes: 	cubo.pas
Yes: 	gasolina.pas
Yes: 	maior.pas
Yes: 	operators.pas
Yes: 	posneg.pas
Yes: 	quadrado.pas
Yes: 	quick.pas
Yes: 	retangulo.pas
Yes: 	sched.pas
Yes: 	somaEProduto.pas
Yes: 	somaParImpar.pas
Yes: 	triangulo.pas
No: 	AssignErr.pas
program AssignErr;

begin
	for i = 2+3 downto 2 do
		i := i-1
end.program{head{"program", "AssignErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", forStmt{"for", "i", "NONE", simpleExpr{unsignedConst{"2", }, "+", unsignedConst{"3", }, }, "downto", unsignedConst{"2", }, "do", assignStmt{var{"i", }, ":=", simpleExpr{var{"i", }, "-", unsignedConst{"1", }, }, }, }, "end", }, ".", }

No: 	BeginErr.pas
program BeginErr;

begi
	a := 2
end.program{head{"program", "BeginErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, "NONE", ".", }

No: 	ColonErr1.pas
program ColonErr1;

type
	turno = record case b : a of a . () end;
	real = real;
begin
	{ Nothing }
end.program{head{"program", "ColonErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", recordType{"record", variantPart{"case", "b", ":", "a", "of", variant{const{"a", }, "NONE", "(", fieldList{}, ")", }, }, "end", }, }, ";", typeDef{"real", "=", type{"real", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	ColonErr2.pas
program ColonErr2;

var
	a, b = int;
	c : int;

begin
	{ Nothing }
end.program{head{"program", "ColonErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{"var", varDec{ids{"a", ",", "b", }, "NONE", type{"int", }, }, ";", varDec{ids{"c", }, ":", type{"int", }, }, ";", }, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	ColonErr3.pas
program ColonErr3;

function f ; int;
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "ColonErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{funcDec{funcHeading{"function", "f", "NONE", type{"int", }, }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	ColonErr4.pas
program ColonErr4;

procedure p(a ; int);
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "ColonErr4", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "p", formalParams{"(", formalParamsSection{ids{"a", }, "NONE", "int", }, ")", }, }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	ColonErr5.pas
program ColonErr5;

begin
	1 ; a;
	while i < 0 do
	begin
		i := i+1
	end
end. program{head{"program", "ColonErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{stmt{label{"1", }, "NONE", }, ";", procStmt{"a", }, ";", whileStmt{"while", expr{var{"i", }, "<", unsignedConst{"0", }, }, "do", block{"begin", assignStmt{var{"i", }, ":=", simpleExpr{var{"i", }, "+", unsignedConst{"1", }, }, }, "end", }, }, }, "end", }, ".", }

No: 	ColonErr6.pas
program ColonErr6;

begin
	case a of
		a ; a := 2;
		b : x := 3
	end
end.program{head{"program", "ColonErr6", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{caseStmt{"case", var{"a", }, "of", caseListElement{const{"a", }, "NONE", stmt{}, }, ";", caseListElement{const{"a", }, ":", stmt{}, }, "NONE", }, ";", procStmt{"b", }, }, "NONE", }, "NONE", }

No: 	ConstErr1.pas
program ConstErr1;

const
	a = +;

begin 
	{ Nothing }
end.program{head{"program", "ConstErr1", ";", }, decs{labelDecs{}, constDefs{"const", constDef{"a", "=", "NONE", }, ";", }, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	ConstErr2.pas
program ConstErr2;

type
	hrs = 0 .. .4;

begin 
	a := 2
end.program{head{"program", "ConstErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"hrs", "=", subrangeType{const{"0", }, "..", "NONE", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, "end", }, ".", }

No: 	ConstErr3.pas
program ConstErr3;

type
	turno = record case b : a of .a : () end;

begin
	a := 2
end.program{head{"program", "ConstErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", recordType{"record", variantPart{"case", "b", ":", "a", "of", "NONE", }, "NONE", }, }, "NONE", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, "end", }, ".", }

No: 	ConstErr4.pas
program ConstErr4;

type
	turno = record case b : a of a, .b: () end;

begin
	a := 2
end.program{head{"program", "ConstErr4", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", recordType{"record", variantPart{"case", "b", ":", "a", "of", variant{consts{const{"a", }, ",", "NONE", }, ":", "(", fieldList{}, ")", }, }, "end", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, "end", }, ".", }

No: 	ConstErr5.pas
program ConstErr5;

begin
	case a of
		.a : a := 2;
		b : a := 3
	end
end.program{head{"program", "ConstErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", caseStmt{"case", var{"a", }, "of", "NONE", ";", caseListElement{const{"b", }, ":", assignStmt{var{"a", }, ":=", unsignedConst{"3", }, }, }, "end", }, "end", }, ".", }

No: 	DoErr1.pas
program DoErr1;

begin
	while a d
		a := 1;

	b := 4;
	c := 5;
end.program{head{"program", "DoErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", whileStmt{"while", var{"a", }, "NONE", procStmt{"d", }, }, "NONE", }, "NONE", }

No: 	DoErr2.pas
program DoErr2;

begin
	for a := 1 to 4 di
		a := a+1;
	b := 4
end.program{head{"program", "DoErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", forStmt{"for", "a", ":=", unsignedConst{"1", }, "to", unsignedConst{"4", }, "NONE", procStmt{"di", }, }, "NONE", }, "NONE", }

No: 	DoErr3.pas
program DoErr3;

begin
	with a od
		a := 1;

	b := 4;
	c := 5
end.program{head{"program", "DoErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", withStmt{"with", var{"a", }, "NONE", procStmt{"od", }, }, "NONE", }, "NONE", }

No: 	DotErr.pas
program DotErr;

begin
	{ Nothing }
endprogram{head{"program", "DotErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, "NONE", }

No: 	EndErr1.pas
program EndErr1;

type
	t = record a : integer ens;

begin
	{ Nothing }
end.program{head{"program", "EndErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"t", "=", recordType{"record", varDec{ids{"a", }, ":", type{"integer", }, }, "NONE", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	EndErr2.pas
program EndErr2;

begin
	{ Nothing }
and.program{head{"program", "EndErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "NONE", }, ".", }

No: 	EndErr3.pas
program ConstErr5;

begin
	case a of
		a : a := 2;
	and

	a := 2;
	b := 4
end.program{head{"program", "ConstErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{caseStmt{"case", var{"a", }, "of", caseListElement{const{"a", }, ":", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, }, ";", "NONE", }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"4", }, }, }, "end", }, ".", }

No: 	EndInputErr.pas
program EndInputErr;

begin
	{ Nothing }
end.

xprogram{head{"program", "EndInputErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", "NONE", }

No: 	EqErr1.pas
program EqErr1;

const
	a := 2;

begin
	b := 4
end.
program{head{"program", "EqErr1", ";", }, decs{labelDecs{}, constDefs{"const", constDef{"a", "NONE", const{"2", }, }, ";", }, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", assignStmt{var{"b", }, ":=", unsignedConst{"4", }, }, "end", }, ".", }

No: 	EqErr2.pas
program EqErr2;

type
	a := real;

begin
	b = 4
end.
program{head{"program", "EqErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "NONE", type{"real", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", procStmt{"b", }, "NONE", }, "NONE", }

No: 	ExprErr1.pas
program ExprErr1;

begin
	a := .5;
	b := 0.4;
	c := 0.6
end.program{head{"program", "ExprErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", "NONE", }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"0.4", }, }, ";", assignStmt{var{"c", }, ":=", unsignedConst{"0.6", }, }, }, "end", }, ".", }

No: 	ExprErr10.pas
program ExprErr10;

begin
	for i := 0 downto .4 do
		a := 1
end.program{head{"program", "ExprErr10", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", forStmt{"for", "i", ":=", unsignedConst{"0", }, "downto", "NONE", "do", assignStmt{var{"a", }, ":=", unsignedConst{"1", }, }, }, "end", }, ".", }

No: 	ExprErr11.pas
program ExprErr11;

begin
	a := a * (.a + 3);
end.program{head{"program", "ExprErr11", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", term{var{"a", }, "*", factor{"(", "NONE", ")", }, }, }, ";", stmt{}, }, "end", }, ".", }

No: 	ExprErr12.pas
program ExprErr12;

begin
	a := [a, .a];

	b := 4;
	c := 6
end.
program{head{"program", "ExprErr12", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", setConstructor{"[", var{"a", }, ",", "NONE", "]", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"4", }, }, ";", assignStmt{var{"c", }, ":=", unsignedConst{"6", }, }, }, "end", }, ".", }

No: 	ExprErr13.pas
program RBrackErr3;

begin
	a := [2, 2.. .a];
end.program{head{"program", "RBrackErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", setConstructor{"[", unsignedConst{"2", }, ",", memberDesignator{unsignedConst{"2", }, "..", "NONE", }, "]", }, }, ";", stmt{}, }, "end", }, ".", }

No: 	ExprErr2.pas
program ExprErr2;

begin
	a[.1, 2] := 2;

	b := 2;
	c := 6
end.program{head{"program", "ExprErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", "[", "NONE", ",", unsignedConst{"2", }, "]", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"c", }, ":=", unsignedConst{"6", }, }, }, "end", }, ".", }

No: 	ExprErr3.pas
program ExprErr3;

begin
	a[2, .4] := 2;
	b := 3;
	c := 5
end.program{head{"program", "ExprErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", "[", unsignedConst{"2", }, ",", "NONE", "]", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"3", }, }, ";", assignStmt{var{"c", }, ":=", unsignedConst{"5", }, }, }, "end", }, ".", }

No: 	ExprErr4.pas
program ExprErr4;

begin
	write(a:1:.4+3);
	a := 2
end.program{head{"program", "ExprErr4", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{procStmt{"write", params{"(", param{var{"a", }, ":", unsignedConst{"1", }, ":", "NONE", }, ")", }, }, ";", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, }, "end", }, ".", }

No: 	ExprErr5.pas
program ExprErr5;

begin
	if .a < 2 then
		a := 1
end.program{head{"program", "ExprErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", ifStmt{"if", "NONE", "then", assignStmt{var{"a", }, ":=", unsignedConst{"1", }, }, }, "end", }, ".", }

No: 	ExprErr6.pas
program ExprErr6;

begin
	case ^a of
		'str' : a := 2;
	end
end.program{head{"program", "ExprErr6", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", caseStmt{"case", "NONE", "of", caseListElement{const{"'str'", }, ":", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, }, ";", "end", }, "end", }, ".", }

No: 	ExprErr7.pas
program ExprErr7;

begin
	repeat
		a := 2
	until ^l+3;
	s := 2+1
end.program{head{"program", "ExprErr7", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{repeatStmt{"repeat", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, "until", "NONE", }, ";", assignStmt{var{"s", }, ":=", simpleExpr{unsignedConst{"2", }, "+", unsignedConst{"1", }, }, }, }, "end", }, ".", }

No: 	ExprErr8.pas
program ExprErr8;

begin
	while ^a+2 do
		a := 1
end.program{head{"program", "ExprErr8", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", whileStmt{"while", "NONE", "do", assignStmt{var{"a", }, ":=", unsignedConst{"1", }, }, }, "end", }, ".", }

No: 	ExprErr9.pas
program ExprErr9;

begin
	for i := ^4 to 32 do
		a := 2
end.program{head{"program", "ExprErr9", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", forStmt{"for", "i", ":=", "NONE", "to", unsignedConst{"32", }, "do", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, }, "end", }, ".", }

No: 	FactorErr.pas
program FactorErr;

begin
	a := a * .b;
end.program{head{"program", "FactorErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", term{var{"a", }, "*", "NONE", }, }, ";", stmt{}, }, "end", }, ".", }

No: 	FormalParamErr1.pas
program FormalParamErr1;

procedure p();
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "FormalParamErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "p", formalParams{"(", "NONE", ")", }, }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	FormalParamErr2.pas
program FormalParamErr2;

procedure p( a : int; );
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "FormalParamErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "p", formalParams{"(", formalParamsSection{ids{"a", }, ":", "int", }, ";", "NONE", ")", }, }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	FuncBodyErr.pas
program FuncBodyErr;

function f : int; 
	a := 2;
	b := 3
end;

begin
	a := 2;
	b := 3
end.program{head{"program", "FuncBodyErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{funcDec{funcHeading{"function", "f", ":", type{"int", }, }, ";", "a", }, "NONE", }, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"3", }, }, }, "end", }, ".", }

No: 	IdErr1.pas
program IdErr1 (id1, ) ;

begin
	{ Nothing }
end.program{head{"program", "IdErr1", "(", ids{"id1", ",", "NONE", }, ")", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr10.pas
program IdErr10;

procedure p(a : 1nt);
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "IdErr10", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "p", formalParams{"(", formalParamsSection{ids{"a", }, ":", "NONE", }, ")", }, }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr11.pas
program IdErr11;

begin
	a.1s := 2;
	b := 3;
	c := 4
end.program{head{"program", "IdErr11", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", ".", "NONE", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"3", }, }, ";", assignStmt{var{"c", }, ":=", unsignedConst{"4", }, }, }, "end", }, ".", }

No: 	IdErr12.pas
program IdErr12;

begin
	for 1a := 2 to 4 do
		a := 4
end.program{head{"program", "IdErr12", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", forStmt{"for", "NONE", ":=", unsignedConst{"2", }, "to", unsignedConst{"4", }, "do", assignStmt{var{"a", }, ":=", unsignedConst{"4", }, }, }, "end", }, ".", }

No: 	IdErr2.pas
program IdErr2;

const
	1a = 2;
	b = 3;

begin
	{ Nothing }
end.program{head{"program", "IdErr2", ";", }, decs{labelDecs{}, constDefs{"const", "NONE", ";", constDef{"b", "=", const{"3", }, }, ";", }, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr3.pas
program IdErr3;

type
	1a = real;
	int = integer;

begin
	{ Nothing }
end.program{head{"program", "IdErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", "NONE", ";", typeDef{"int", "=", type{"integer", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr4.pas
program IdErr4;

type
	1a = ^2real;
	b = int;

begin
	{ Nothing }
end.program{head{"program", "IdErr4", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", "NONE", ";", typeDef{"b", "=", type{"int", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr5.pas
program IdErr5;

type
	turno = (2M, T, N);

begin
	{ Nothing }
end.program{head{"program", "IdErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", enumType{"(", "NONE", ")", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr6.pas
program IdErr6;

type
	turno = record case 1a of a : () end;
	a = integer;

begin
	{ Nothing }
end.program{head{"program", "IdErr6", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", recordType{"record", variantPart{"case", "NONE", "of", variant{const{"a", }, ":", "(", fieldList{}, ")", }, }, "end", }, }, ";", typeDef{"a", "=", type{"integer", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr7.pas
program IdErr7;

type
	turno = record case b : 1a of a : () end;
	b = integer;

begin
	{ Nothing }
end.program{head{"program", "IdErr7", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", recordType{"record", variantPart{"case", "b", ":", "NONE", "of", variant{const{"a", }, ":", "(", fieldList{}, ")", }, }, "end", }, }, ";", typeDef{"b", "=", type{"integer", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr8.pas
program IdErr8;

procedure 1p; 
begin
	{ Nothing }
end;
	
begin
	{ Nothing }
end.program{head{"program", "IdErr8", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "NONE", }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	IdErr9.pas
program IdErr9;

function 1f : int; 
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "IdErr9", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{funcDec{funcHeading{"function", "NONE", ":", type{"int", }, }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	LBrackErr.pas
program LBrackErr;

type
	a = array 2..3] of integer;

begin
	{ Nothing }
end.program{head{"program", "LBrackErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", arrayType{"array", "NONE", subrangeType{const{"2", }, "..", const{"3", }, }, "]", "of", type{"integer", }, }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	LParErr.pas
program LParErr;

type
	a = record
			case id of
				1, 2 : (id : int);
				2, 3 : oi : int);
		end;
	b = integer;

begin
	{ Nothing }
end.program{head{"program", "LParErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", recordType{"record", fieldList{variantPart{"case", "id", "of", variant{consts{const{"1", }, ",", const{"2", }, }, ":", "(", varDec{ids{"id", }, ":", type{"int", }, }, ")", }, ";", variant{consts{const{"2", }, ",", const{"3", }, }, ":", "NONE", varDec{ids{"oi", }, ":", type{"int", }, }, ")", }, }, ";", }, "end", }, }, ";", typeDef{"b", "=", type{"integer", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	LabelErr1.pas
program LabelErr1;

label
	, 2;

begin
	{ Nothing }
end.program{head{"program", "LabelErr1", ";", }, decs{labelDecs{"label", "NONE", ";", }, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	LabelErr2.pas
program LabelErr2;

label
	1, a;
begin
	{ Nothing }
end. program{head{"program", "LabelErr2", ";", }, decs{labelDecs{"label", labels{label{"1", }, ",", "NONE", }, ";", }, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	LabelErr3.pas
program LabelErr3;

begin
	goto a;
	b := 3;
end. program{head{"program", "LabelErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{gotoStmt{"goto", "NONE", }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"3", }, }, ";", stmt{}, }, "end", }, ".", }

No: 	OfErr1.pas
program OfErr1;

type
	a = array [1..2] integer;

begin
	{ Nothing }
end.program{head{"program", "OfErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", arrayType{"array", "[", subrangeType{const{"1", }, "..", const{"2", }, }, "]", "NONE", type{"integer", }, }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	OfErr2.pas
program OfErr2;

type
	a = set integer;

begin
	{ Nothing }
end.program{head{"program", "OfErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", setType{"set", "NONE", ordinalType{"integer", }, }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	OfErr3.pas
program OfErr3;

type
	a = file integer;

begin
	{ Nothing }
end.program{head{"program", "OfErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", fileType{"file", "NONE", type{"integer", }, }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	OfErr4.pas
program OfErr4;

type
	turno = record case b : a odf a : () end;
	b = integer;

begin
	{ Nothing }
end.program{head{"program", "OfErr4", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", recordType{"record", variantPart{"case", "b", ":", "a", "NONE", variant{const{"odf", }, "NONE", "(", fieldList{}, ")", }, }, "end", }, }, ";", typeDef{"b", "=", type{"integer", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	OfErr5.pas
program OfErr5;

begin
	case a ofd
		'str' : a := 2;
		'stu' : b := 3;
	end
end.program{head{"program", "OfErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", caseStmt{"case", var{"a", }, "NONE", caseListElement{const{"ofd", }, "NONE", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, }, ";", caseListElement{const{"'stu'", }, ":", assignStmt{var{"b", }, ":=", unsignedConst{"3", }, }, }, ";", "end", }, "end", }, ".", }

No: 	OrdinalTypeErr1.pas
program OrdinalTypeErr1;

type
	a = array [.1 .. 2, 2 .. 20] of int;

begin
	{ Nothing }
end.program{head{"program", "OrdinalTypeErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", arrayType{"array", "[", "NONE", ",", subrangeType{const{"2", }, "..", const{"20", }, }, "]", "of", type{"int", }, }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	OrdinalTypeErr2.pas
program OrdinalTypeErr2;

type
	a = array [2..3, .1 .. 3, 2 .. 20] of int;

begin
	{ Nothing }
end.program{head{"program", "OrdinalTypeErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", arrayType{"array", "[", subrangeType{const{"2", }, "..", const{"3", }, }, ",", "NONE", "]", "of", type{"int", }, }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	OrdinalTypeErr3.pas
program OrdinalTypeErr3;

type
	a = set of 1nt;

begin
	{ Nothing }
end.program{head{"program", "OrdinalTypeErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", setType{"set", "of", "NONE", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	ProcBodyErr.pas
program ProcBodyErr;

procedure p;
	a := 2;
	b := 3
end;

begin
	a := 2;
	b := 3
end.program{head{"program", "ProcBodyErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "p", }, ";", "a", }, "NONE", }, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"3", }, }, }, "end", }, ".", }

No: 	ProgErr.pas
prog HelloWorld;

label 2;

begin
	{ Nothing }
end.program{"NONE", decs{labelDecs{"label", label{"2", }, ";", }, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	ProgNameErr.pas
program 1p;

begin
	{ Nothing }
end.program{head{"program", "NONE", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	RBrackErr1.pas
program RBrackErr1;

type
	a = array [1..2 of integer;

begin
	{ Nothing }
end.program{head{"program", "RBrackErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", arrayType{"array", "[", subrangeType{const{"1", }, "..", const{"2", }, }, "NONE", "of", type{"integer", }, }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	RBrackErr2.pas
program RBrackErr2;

begin
	a[2, 2 := 2;
	b := 2;
	c := 5
end.program{head{"program", "RBrackErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", "[", unsignedConst{"2", }, ",", unsignedConst{"2", }, "NONE", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"2", }, }, ";", assignStmt{var{"c", }, ":=", unsignedConst{"5", }, }, }, "end", }, ".", }

No: 	RBrackErr3.pas
program RBrackErr3;

begin
	a := [2, 2};
	b := 5;
	c := 4;
end.program{head{"program", "RBrackErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", setConstructor{"[", unsignedConst{"2", }, ",", unsignedConst{"2", }, "NONE", }, }, ";", assignStmt{var{"b", }, ":=", unsignedConst{"5", }, }, ";", assignStmt{var{"c", }, ":=", unsignedConst{"4", }, }, ";", stmt{}, }, "end", }, ".", }

No: 	RParErr1.pas
program RParErr1 (id1, id2;

begin
	{ Nothing }
end.program{head{"program", "RParErr1", "(", ids{"id1", ",", "id2", }, "NONE", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	RParErr2.pas
program RParErr2;

type
	turno = (M, T, N;

begin
	{ Nothing }
end.program{head{"program", "RParErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"turno", "=", enumType{"(", ids{"M", ",", "T", ",", "N", }, "NONE", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	RParErr3.pas
program RParErr3;

type
	a = record
			case id of
				1, 2 : (id : int;
				2, 3 : (oi : int);
		end;

begin
	{ Nothing }
end.program{head{"program", "RParErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", recordType{"record", variantPart{"case", "id", "of", variant{consts{const{"1", }, ",", const{"2", }, }, ":", "(", fieldList{varDec{ids{"id", }, ":", type{"int", }, }, ";", }, "NONE", }, }, "NONE", }, }, "NONE", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	RParErr4.pas
program RParErr3;

procedure p(a : int];
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "RParErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "p", formalParams{"(", formalParamsSection{ids{"a", }, ":", "int", }, "NONE", }, }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	RParErr5.pas
program RParErr5;

begin
	writeln(a
end.program{head{"program", "RParErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", procStmt{"writeln", params{"(", var{"a", }, "NONE", }, }, "end", }, ".", }

No: 	RParErr6.pas
program RParErr6;

begin
	a := (a * (a + 3);
end.program{head{"program", "RParErr6", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", factor{"(", term{var{"a", }, "*", factor{"(", simpleExpr{var{"a", }, "+", unsignedConst{"3", }, }, ")", }, }, "NONE", }, }, ";", stmt{}, }, "end", }, ".", }

No: 	RealParamErr.pas
program RealParamErr;

begin
	writeln(a,.b);
end.program{head{"program", "RealParamErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{procStmt{"writeln", params{"(", var{"a", }, ",", "NONE", ")", }, }, ";", stmt{}, }, "end", }, ".", }

No: 	SemiErr1.pas
program SemiErr1 (id1,id2)

begin
	{ Nothing }
end.program{head{"program", "SemiErr1", "(", ids{"id1", ",", "id2", }, ")", "NONE", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr10.pas
program SemiErr10;

procedure a
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "SemiErr10", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "a", }, "NONE", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr11.pas
program SemiErr11;

function f : int
begin
	{ Nothing }
end;
	
begin
	{ Nothing }
end.program{head{"program", "SemiErr11", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{funcDec{funcHeading{"function", "f", ":", type{"int", }, }, "NONE", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr2.pas
program SemiErr2;

label
	2, 3

begin
	{ Nothing }
end.program{head{"program", "SemiErr2", ";", }, decs{labelDecs{"label", labels{label{"2", }, ",", label{"3", }, }, "NONE", }, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr3.pas
program SemiErr3;

const
	c = 1

begin
	{ Nothing }
end.program{head{"program", "SemiErr3", ";", }, decs{labelDecs{}, constDefs{"const", constDef{"c", "=", const{"1", }, }, "NONE", }, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr4.pas
program SemiErr4;

const
	a = 1;
	b = 2

begin
	{ Nothing }
end.program{head{"program", "SemiErr4", ";", }, decs{labelDecs{}, constDefs{"const", constDef{"a", "=", const{"1", }, }, ";", constDef{"b", "=", const{"2", }, }, "NONE", }, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr5.pas
program SemiErr5;

type
	a = real
	b = real;

begin
	{ Nothing }
end.program{head{"program", "SemiErr5", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", type{"real", }, }, "NONE", typeDef{"b", "=", type{"real", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr6.pas
program SemiErr6;

type
	a = real;
	b = real

begin
	{ Nothing }
end.program{head{"program", "SemiErr6", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", type{"real", }, }, ";", typeDef{"b", "=", type{"real", }, }, "NONE", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr7.pas
program SemiErr7;

var
	a : int,

begin
	{ Nothing }
end.program{head{"program", "SemiErr7", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{"var", varDec{ids{"a", }, ":", type{"int", }, }, "NONE", }, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr8.pas
program SemiErr8;

var
	a : int;
	b : int.

begin
	{ Nothing }
end.program{head{"program", "SemiErr8", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{"var", varDec{ids{"a", }, ":", type{"int", }, }, ";", varDec{ids{"b", }, ":", type{"int", }, }, "NONE", }, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SemiErr9.pas
program SemiErr9;

procedure a;
begin

end

begin
	{ Nothing }
end.program{head{"program", "SemiErr9", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{procDec{procHeading{"procedure", "a", }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, "NONE", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	SimpleExprErr.pas
program SimpleExprErr;

begin
	if a <> then
		a := 1;
end.program{head{"program", "SimpleExprErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{ifStmt{"if", expr{var{"a", }, "<>", "NONE", }, "then", assignStmt{var{"a", }, ":=", unsignedConst{"1", }, }, }, ";", stmt{}, }, "end", }, ".", }

No: 	TermErr.pas
program TermErr;

begin
	a := a + ;
end.program{head{"program", "TermErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{assignStmt{var{"a", }, ":=", simpleExpr{var{"a", }, "+", "NONE", }, }, ";", stmt{}, }, "end", }, ".", }

No: 	ThenErr.pas
program ThenErr;

begin
	if a = 1 the
		a := 2;

	b := 3;
	c := 5
end.program{head{"program", "ThenErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", ifStmt{"if", expr{var{"a", }, "=", unsignedConst{"1", }, }, "NONE", procStmt{"the", }, }, "NONE", }, "NONE", }

No: 	ToDownToErr.pas
program ToDownToErr;

begin
	for i := 0 ti 3 do
		a := 1;
	while a > 2 do
	begin
		writeln('Hi');
	end
end.program{head{"program", "ToDownToErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmts{forStmt{"for", "i", ":=", unsignedConst{"0", }, "NONE", var{"ti", }, "NONE", stmt{label{"3", }, "NONE", assignStmt{var{"a", }, ":=", unsignedConst{"1", }, }, }, }, ";", whileStmt{"while", expr{var{"a", }, ">", unsignedConst{"2", }, }, "do", block{"begin", stmts{procStmt{"writeln", params{"(", unsignedConst{"'Hi'", }, ")", }, }, ";", stmt{}, }, "end", }, }, }, "end", }, ".", }

No: 	TypeErr1.pas
program TypeErr1;

type
	novo = 1;

begin
	{ Nothing }
end.program{head{"program", "TypeErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"novo", "=", "NONE", }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	TypeErr2.pas
program TypeErr2;

type
	a = array [2..3] of 1nt;

begin
	{ Nothing }
end.program{head{"program", "TypeErr2", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"a", "=", arrayType{"array", "[", subrangeType{const{"2", }, "..", const{"3", }, }, "]", "of", "NONE", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	TypeErr3.pas
program TypeErr3;

type
	novo = file of 1nt;

begin
	{ Nothing }
end.program{head{"program", "TypeErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{"type", typeDef{"novo", "=", fileType{"file", "of", "NONE", }, }, ";", }, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	TypeErr4.pas
program TypeErr4;

var
	a : 1nt;

begin
	{ Nothing }
end.program{head{"program", "TypeErr4", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{"var", varDec{ids{"a", }, ":", "NONE", }, ";", }, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, ".", }

No: 	TypeErr5.pas
program ColonErr3;

function f : 1nt;
begin
	{ Nothing }
end;

begin
	{ Nothing }
end.program{head{"program", "ColonErr3", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{funcDec{funcHeading{"function", "f", ":", "NONE", }, ";", decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", stmt{}, "end", }, }, ";", }, }, block{"begin", stmt{}, "end", }, ".", }

No: 	UntilErr.pas
program UntilErr;

begin
	repeat
		a := 2
	unti 3+3;

	a := 2;
	b := 3
end.program{head{"program", "UntilErr", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", repeatStmt{"repeat", assignStmt{var{"a", }, ":=", unsignedConst{"2", }, }, "NONE", var{"unti", }, }, "NONE", }, "NONE", }

No: 	VarErr1.pas
program VarErr1;

begin
	with .a < 3 do
		a := 1
end.program{head{"program", "VarErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", withStmt{"with", "NONE", "do", assignStmt{var{"a", }, ":=", unsignedConst{"1", }, }, }, "end", }, ".", }

No: 	VarErr2.pas
program VarErr1;

begin
	with a, .b, c do
		a := 1
end.program{head{"program", "VarErr1", ";", }, decs{labelDecs{}, constDefs{}, typeDefs{}, varDecs{}, procAndFuncDecs{}, }, block{"begin", withStmt{"with", var{"a", }, ",", "NONE", "do", assignStmt{var{"a", }, ":=", unsignedConst{"1", }, }, }, "end", }, ".", }

irec: 	101	 ifail: 	0
